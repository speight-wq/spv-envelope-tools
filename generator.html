<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SPV Envelope Generator ‚Äî SPV Envelope Tools</title>
  <style>
    :root { --bg: #fff; --surface: #f8f9fa; --border: #dee2e6; --text: #212529; --text-2: #495057; --text-3: #868e96; --accent: #228be6; --success: #2f9e44; --success-bg: #d3f9d8; --warning: #e67700; --warning-bg: #fff3bf; --danger: #e03131; --danger-bg: #ffe3e3; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); line-height: 1.6; padding: 32px 24px; max-width: 900px; margin: 0 auto; }
    h1 { font-size: 1.75rem; font-weight: 600; margin-bottom: 8px; }
    .subtitle { color: var(--text-2); margin-bottom: 24px; }
    .subtitle a { color: var(--accent); text-decoration: none; }
    .notice { background: var(--warning-bg); border: 2px solid var(--warning); border-radius: 8px; padding: 16px 20px; margin-bottom: 32px; }
    .notice-title { font-weight: 600; margin-bottom: 4px; }
    .notice-text { color: var(--text-2); font-size: 0.95rem; }
    .section { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 24px; margin-bottom: 24px; }
    .section-title { font-size: 1rem; font-weight: 600; margin-bottom: 16px; }
    .step-number { display: inline-block; width: 24px; height: 24px; background: var(--accent); color: white; border-radius: 50%; text-align: center; line-height: 24px; font-size: 0.8rem; font-weight: 600; margin-right: 8px; }
    .field { margin-bottom: 16px; }
    .label { display: block; font-size: 0.875rem; font-weight: 500; color: var(--text-2); margin-bottom: 6px; }
    .input { width: 100%; padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-family: monospace; font-size: 0.875rem; }
    .input:focus { outline: none; border-color: var(--accent); }
    textarea.input { min-height: 100px; resize: vertical; }
    .hint { font-size: 0.8rem; color: var(--text-3); margin-top: 4px; }
    .btn { display: inline-block; padding: 12px 24px; border-radius: 6px; font-size: 0.875rem; font-weight: 500; cursor: pointer; border: none; }
    .btn-primary { background: var(--accent); color: white; }
    .btn-secondary { background: var(--bg); color: var(--text); border: 1px solid var(--border); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .btn-row { display: flex; gap: 8px; margin-top: 16px; flex-wrap: wrap; }
    .hidden { display: none !important; }
    .divider { height: 1px; background: var(--border); margin: 16px 0; }
    
    /* Tabs */
    .tabs { display: flex; gap: 4px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 4px; margin-bottom: 20px; }
    .tab { flex: 1; padding: 10px 16px; background: transparent; border: none; border-radius: 6px; color: var(--text-2); font-size: 0.875rem; font-weight: 500; cursor: pointer; text-align: center; }
    .tab:hover { color: var(--text); }
    .tab.active { background: var(--accent); color: white; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    /* Progress */
    .progress-bar { height: 8px; background: var(--border); border-radius: 4px; overflow: hidden; margin-bottom: 8px; }
    .progress-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.3s ease; }
    .progress-text { font-size: 0.85rem; color: var(--text-2); }
    
    /* Results */
    .result-box { border-radius: 8px; padding: 20px; margin-top: 20px; }
    .result-box.success { background: var(--success-bg); border: 2px solid var(--success); }
    .result-box.warning { background: var(--warning-bg); border: 2px solid var(--warning); }
    .result-title { font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
    
    /* Stats */
    .stats-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 20px; }
    .stat-item { background: var(--bg); padding: 16px; border-radius: 8px; text-align: center; }
    .stat-value { font-size: 1.5rem; font-weight: 600; color: var(--accent); }
    .stat-label { font-size: 0.8rem; color: var(--text-3); text-transform: uppercase; }
    
    /* Envelope list */
    .envelope-list { max-height: 400px; overflow-y: auto; }
    .envelope-item { background: var(--bg); border: 1px solid var(--border); border-radius: 6px; padding: 12px 16px; margin-bottom: 8px; cursor: pointer; transition: border-color 0.2s; }
    .envelope-item:hover { border-color: var(--accent); }
    .envelope-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
    .envelope-txid { font-family: monospace; font-size: 0.85rem; color: var(--accent); }
    .envelope-amount { font-weight: 500; }
    .envelope-meta { font-size: 0.8rem; color: var(--text-3); display: flex; gap: 12px; flex-wrap: wrap; }
    .envelope-status { padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: 500; }
    .envelope-status.valid { background: var(--success-bg); color: var(--success); }
    .envelope-status.invalid { background: var(--danger-bg); color: var(--danger); }
    .envelope-status.unconfirmed { background: var(--warning-bg); color: var(--warning); }
    
    /* Validation checks */
    .check-list { list-style: none; margin-top: 12px; }
    .check-item { display: flex; align-items: center; gap: 8px; padding: 6px 0; font-size: 0.85rem; }
    .check-icon { width: 18px; height: 18px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; flex-shrink: 0; }
    .check-icon.pass { background: var(--success); color: white; }
    .check-icon.fail { background: var(--danger); color: white; }
    .check-icon.warn { background: var(--warning); color: white; }
    
    /* Quote */
    .quote { background: var(--surface); border-left: 4px solid var(--accent); padding: 16px 20px; margin: 32px 0; font-style: italic; color: var(--text-2); font-size: 0.9rem; }
    .quote-author { font-style: normal; font-weight: 600; color: var(--text); margin-top: 8px; display: block; }
    
    /* Footer */
    footer { text-align: center; color: var(--text-3); font-size: 0.8rem; margin-top: 48px; padding-top: 24px; border-top: 1px solid var(--border); }
    footer a { color: var(--accent); text-decoration: none; }
    .integrity-display { margin-top: 8px; padding: 8px 12px; background: var(--surface); border-radius: 4px; font-size: 0.75rem; display: inline-block; }
    .integrity-label { color: var(--text-3); }
    .integrity-display code { color: var(--text); font-family: monospace; margin-left: 4px; cursor: pointer; }
    
    /* Modal */
    .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; }
    .modal-box { background: var(--bg); border-radius: 12px; padding: 24px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; }
    .modal-title { font-size: 1.1rem; font-weight: 600; margin-bottom: 16px; }
    .modal-json { background: var(--surface); border: 1px solid var(--border); border-radius: 6px; padding: 16px; font-family: monospace; font-size: 0.8rem; white-space: pre-wrap; word-break: break-all; max-height: 400px; overflow-y: auto; }
  </style>
</head>
<body>
  <h1>SPV Envelope Generator</h1>
  <p class="subtitle">Generate SPV envelopes for offline verification. Part of <a href="https://github.com/speight-wq/spv-envelope-tools">SPV Envelope Tools</a>.</p>

  <div class="notice">
    <div class="notice-title">‚ö° Requires Network</div>
    <div class="notice-text">This tool fetches transaction data and merkle proofs from WhatsOnChain. Generated envelopes can then be verified completely offline using the <a href="verifier.html">Verifier</a>.</div>
  </div>

  <div class="section">
    <div class="section-title"><span class="step-number">1</span>Select Input Method</div>
    
    <div class="tabs">
      <button class="tab active" data-tab="txid">By TXID</button>
      <button class="tab" data-tab="address">By Address</button>
      <button class="tab" data-tab="bulk">Bulk Addresses</button>
    </div>
    
    <div id="tab-txid" class="tab-content active">
      <div class="field">
        <label class="label">Transaction ID</label>
        <input type="text" class="input" id="input-txid" placeholder="64-character transaction hash">
        <div class="hint">Generate envelope for a specific confirmed transaction.</div>
      </div>
    </div>
    
    <div id="tab-address" class="tab-content">
      <div class="field">
        <label class="label">BSV Address</label>
        <input type="text" class="input" id="input-address" placeholder="1... or 3... address">
        <div class="hint">Generate envelopes for all UTXOs belonging to this address.</div>
      </div>
    </div>
    
    <div id="tab-bulk" class="tab-content">
      <div class="field">
        <label class="label">Addresses (one per line)</label>
        <textarea class="input" id="input-bulk" placeholder="1address1...&#10;1address2...&#10;1address3..."></textarea>
        <div class="hint">Process multiple addresses. Rate limited to avoid API throttling.</div>
      </div>
    </div>
    
    <div class="btn-row">
      <button class="btn btn-primary" id="btn-generate">Generate Envelopes</button>
    </div>
    
    <div id="progress-section" class="hidden" style="margin-top: 20px;">
      <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
      <div class="progress-text" id="progress-text">Processing...</div>
    </div>
  </div>

  <div id="results-section" class="section hidden">
    <div class="section-title"><span class="step-number">2</span>Generated Envelopes</div>
    
    <div class="stats-grid">
      <div class="stat-item">
        <div class="stat-value" id="stat-total">0</div>
        <div class="stat-label">Envelopes</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" id="stat-valid">0</div>
        <div class="stat-label">With Proofs</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" id="stat-balance">0</div>
        <div class="stat-label">Total BSV</div>
      </div>
    </div>
    
    <div id="validation-summary"></div>
    
    <div class="envelope-list" id="envelope-list"></div>
    
    <div class="btn-row">
      <button class="btn btn-primary" id="btn-download">Download All</button>
      <button class="btn btn-secondary" id="btn-copy">Copy to Clipboard</button>
    </div>
  </div>

  <div class="quote">
    "It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he's convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it's timestamped in."
    <span class="quote-author">‚Äî Satoshi Nakamoto, Bitcoin Whitepaper, Section 8: Simplified Payment Verification</span>
  </div>

  <footer>
    <a href="https://github.com/speight-wq/spv-envelope-tools">SPV Envelope Tools</a><br>
    Generator ¬∑ <a href="verifier.html">Verifier</a> ¬∑ <a href="signer.html">Signer</a><br><br>
    Envelopes can be verified completely offline.<br>
    <div class="integrity-display">
      <span class="integrity-label">Page Integrity SHA-256:</span>
      <code id="integrity-value" title="Click to copy">Computing...</code>
    </div>
  </footer>

  <div id="modal" class="modal-overlay hidden">
    <div class="modal-box">
      <div class="modal-title">Envelope Details</div>
      <div class="modal-json" id="modal-json"></div>
      <div class="btn-row" style="margin-top: 16px;">
        <button class="btn btn-secondary" onclick="closeModal()">Close</button>
        <button class="btn btn-primary" onclick="copyEnvelope()">Copy JSON</button>
      </div>
    </div>
  </div>

  <script>
  (function() {
    'use strict';

    // ==========================================
    // SHA-256 Implementation (for validation)
    // ==========================================
    const SHA256 = (function() {
      const K = new Uint32Array([
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
      ]);

      function hash(data) {
        if (typeof data === 'string') data = hexToBytes(data);
        if (!(data instanceof Uint8Array)) data = new Uint8Array(data);
        
        const msgLen = data.length;
        const totalLen = Math.ceil((msgLen + 9) / 64) * 64;
        const padded = new Uint8Array(totalLen);
        padded.set(data);
        padded[msgLen] = 0x80;
        const view = new DataView(padded.buffer);
        view.setUint32(totalLen - 4, msgLen * 8, false);
        
        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;
        
        const W = new Uint32Array(64);
        
        for (let i = 0; i < padded.length; i += 64) {
          for (let j = 0; j < 16; j++) W[j] = view.getUint32(i + j * 4, false);
          for (let j = 16; j < 64; j++) {
            const s0 = ((W[j-15] >>> 7) | (W[j-15] << 25)) ^ ((W[j-15] >>> 18) | (W[j-15] << 14)) ^ (W[j-15] >>> 3);
            const s1 = ((W[j-2] >>> 17) | (W[j-2] << 15)) ^ ((W[j-2] >>> 19) | (W[j-2] << 13)) ^ (W[j-2] >>> 10);
            W[j] = (W[j-16] + s0 + W[j-7] + s1) >>> 0;
          }
          
          let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7;
          
          for (let j = 0; j < 64; j++) {
            const S1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
            const ch = (e & f) ^ (~e & g);
            const t1 = (h + S1 + ch + K[j] + W[j]) >>> 0;
            const S0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
            const maj = (a & b) ^ (a & c) ^ (b & c);
            const t2 = (S0 + maj) >>> 0;
            
            h = g; g = f; f = e; e = (d + t1) >>> 0;
            d = c; c = b; b = a; a = (t1 + t2) >>> 0;
          }
          
          h0 = (h0 + a) >>> 0; h1 = (h1 + b) >>> 0; h2 = (h2 + c) >>> 0; h3 = (h3 + d) >>> 0;
          h4 = (h4 + e) >>> 0; h5 = (h5 + f) >>> 0; h6 = (h6 + g) >>> 0; h7 = (h7 + h) >>> 0;
        }
        
        const result = new Uint8Array(32);
        const rv = new DataView(result.buffer);
        rv.setUint32(0, h0, false); rv.setUint32(4, h1, false);
        rv.setUint32(8, h2, false); rv.setUint32(12, h3, false);
        rv.setUint32(16, h4, false); rv.setUint32(20, h5, false);
        rv.setUint32(24, h6, false); rv.setUint32(28, h7, false);
        return result;
      }
      
      return { hash };
    })();

    // ==========================================
    // Utility Functions
    // ==========================================
    function hexToBytes(hex) {
      hex = hex.replace(/^0x/, '');
      if (hex.length % 2) hex = '0' + hex;
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
      }
      return bytes;
    }

    function bytesToHex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function reverseBytes(bytes) {
      return new Uint8Array(Array.from(bytes).reverse());
    }

    function reverseHex(hex) {
      return bytesToHex(reverseBytes(hexToBytes(hex)));
    }

    function hash256(data) {
      return SHA256.hash(SHA256.hash(data));
    }

    function readUInt32LE(bytes, offset) {
      return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);
    }

    // ==========================================
    // Proof-of-Work Validation
    // ==========================================
    function nbitsToTarget(nbits) {
      const exp = (nbits >>> 24) & 0xff;
      const mant = nbits & 0x007fffff;
      if (nbits & 0x00800000) return 0n;
      if (exp <= 3) return BigInt(mant) >> BigInt(8 * (3 - exp));
      return BigInt(mant) << BigInt(8 * (exp - 3));
    }

    function validatePoW(headerHex) {
      const bytes = hexToBytes(headerHex);
      if (bytes.length !== 80) return { valid: false, error: 'Header not 80 bytes' };
      
      const nbits = readUInt32LE(bytes, 72);
      const target = nbitsToTarget(nbits);
      if (target === 0n) return { valid: false, error: 'Invalid target' };
      
      const hashBytes = hash256(bytes);
      const hashInt = BigInt('0x' + bytesToHex(reverseBytes(hashBytes)));
      
      return { valid: hashInt <= target, hashInt, target, nbits };
    }

    // ==========================================
    // Merkle Proof Validation
    // ==========================================
    function validateMerkleProof(txid, nodes, index, expectedRoot) {
      try {
        let current = txid.toLowerCase();
        
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i].toLowerCase();
          const isRight = (index >> i) & 1;
          
          let combined;
          if (isRight) {
            combined = reverseHex(node) + reverseHex(current);
          } else {
            combined = reverseHex(current) + reverseHex(node);
          }
          
          current = reverseHex(bytesToHex(hash256(hexToBytes(combined))));
        }
        
        return current.toLowerCase() === expectedRoot.toLowerCase();
      } catch (e) {
        return false;
      }
    }

    // ==========================================
    // API Configuration
    // ==========================================
    const API_BASE = 'https://api.whatsonchain.com/v1/bsv/main';

    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) {
        if (res.status === 404) return null;
        throw new Error(`HTTP ${res.status}`);
      }
      return res.json();
    }

    async function fetchText(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.text();
    }

    // ==========================================
    // API Functions
    // ==========================================
    async function getTransaction(txid) {
      return await fetchJson(`${API_BASE}/tx/hash/${txid}`);
    }

    async function getRawTx(txid) {
      return await fetchText(`${API_BASE}/tx/${txid}/hex`);
    }

    async function getAddressUtxos(address) {
      const data = await fetchJson(`${API_BASE}/address/${address}/unspent`);
      return data || [];
    }

    async function getMerkleProof(txid) {
      // Try TSC format first (more reliable)
      try {
        const res = await fetch(`${API_BASE}/tx/${txid}/proof/tsc`);
        if (res.ok) {
          const text = await res.text();
          if (text && text !== 'null' && text !== '[]') {
            return { data: JSON.parse(text), format: 'tsc' };
          }
        }
      } catch (e) {}

      // Try standard format
      try {
        const res = await fetch(`${API_BASE}/tx/${txid}/proof`);
        if (res.ok) {
          const text = await res.text();
          if (text && text !== 'null' && text !== '[]') {
            return { data: JSON.parse(text), format: 'standard' };
          }
        }
      } catch (e) {}

      return null;
    }

    async function getBlockHeader(blockHash) {
      try {
        const data = await fetchJson(`${API_BASE}/block/${blockHash}/header`);
        if (!data) return null;
        
        // Construct 80-byte header from components
        const version = toLittleEndian(data.version, 4);
        const prevBlock = reverseHex(data.previousblockhash || '0'.repeat(64));
        const merkleRoot = reverseHex(data.merkleroot);
        const time = toLittleEndian(data.time, 4);
        const bits = typeof data.bits === 'string' 
          ? reverseHex(data.bits.padStart(8, '0'))
          : toLittleEndian(data.bits, 4);
        const nonce = toLittleEndian(data.nonce, 4);
        
        const header = version + prevBlock + merkleRoot + time + bits + nonce;
        return header.length === 160 ? header : null;
      } catch (e) {
        return null;
      }
    }

    function toLittleEndian(value, bytes) {
      if (typeof value === 'string' && value.startsWith('0x')) {
        value = parseInt(value, 16);
      }
      if (typeof value === 'string' && /^[0-9a-fA-F]+$/.test(value)) {
        return reverseHex(value.padStart(bytes * 2, '0'));
      }
      let hex = value.toString(16).padStart(bytes * 2, '0');
      return reverseHex(hex);
    }

    // ==========================================
    // Envelope Generation
    // ==========================================
    async function generateEnvelope(txid, vout = 0) {
      const validation = { checks: [], passed: true };
      
      // Fetch transaction data
      const txInfo = await getTransaction(txid);
      if (!txInfo) throw new Error('Transaction not found');
      
      const rawTx = await getRawTx(txid);
      if (!rawTx) throw new Error('Could not fetch raw transaction');
      
      // Validate txid matches rawTx
      const computedTxid = reverseHex(bytesToHex(hash256(hexToBytes(rawTx))));
      const txidMatch = computedTxid.toLowerCase() === txid.toLowerCase();
      validation.checks.push({ name: 'TXID matches rawTx', pass: txidMatch });
      if (!txidMatch) validation.passed = false;
      
      // Build envelope
      const envelope = {
        txid,
        vout,
        rawTx,
        satoshis: txInfo.vout?.[vout]?.value ? Math.round(txInfo.vout[vout].value * 100000000) : null,
        blockHeight: txInfo.blockheight || null,
        blockHash: txInfo.blockhash || null,
        confirmations: txInfo.confirmations || 0
      };
      
      // Get merkle proof if confirmed
      if (txInfo.confirmations > 0) {
        const proofResult = await getMerkleProof(txid);
        
        if (proofResult && proofResult.data) {
          const proofData = Array.isArray(proofResult.data) ? proofResult.data[0] : proofResult.data;
          
          if (proofData && proofData.nodes) {
            envelope.proof = {
              nodes: proofData.nodes,
              index: proofData.index ?? 0
            };
            
            // Get block header
            if (envelope.blockHash) {
              const blockHeader = await getBlockHeader(envelope.blockHash);
              
              if (blockHeader) {
                envelope.blockHeader = blockHeader;
                
                // VALIDATION: Check PoW
                const powResult = validatePoW(blockHeader);
                validation.checks.push({ 
                  name: 'Block header PoW valid', 
                  pass: powResult.valid,
                  detail: powResult.valid ? 'Hash meets target' : powResult.error
                });
                if (!powResult.valid) validation.passed = false;
                
                // VALIDATION: Check merkle proof
                const headerBytes = hexToBytes(blockHeader);
                const merkleRoot = reverseHex(bytesToHex(headerBytes.slice(36, 68)));
                
                const merkleValid = validateMerkleProof(
                  txid,
                  envelope.proof.nodes,
                  envelope.proof.index,
                  merkleRoot
                );
                validation.checks.push({ 
                  name: 'Merkle proof valid', 
                  pass: merkleValid,
                  detail: merkleValid ? 'Proof computes to header merkle root' : 'Proof does not match'
                });
                if (!merkleValid) validation.passed = false;
                
                envelope.hasProof = true;
              } else {
                validation.checks.push({ name: 'Block header fetch', pass: false, detail: 'Could not retrieve header' });
                validation.passed = false;
              }
            }
          }
        }
        
        if (!envelope.hasProof) {
          validation.checks.push({ name: 'Merkle proof available', pass: false, detail: 'API did not return proof' });
        }
      } else {
        validation.checks.push({ name: 'Transaction confirmed', pass: false, detail: 'Unconfirmed - no proof available' });
      }
      
      envelope.validation = validation;
      envelope.generatedAt = new Date().toISOString();
      
      return envelope;
    }

    // ==========================================
    // UI State
    // ==========================================
    let currentTab = 'txid';
    let allResults = [];
    let currentEnvelope = null;

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
        currentTab = tab.dataset.tab;
      });
    });

    // Generate button
    document.getElementById('btn-generate').addEventListener('click', generate);

    async function generate() {
      const btn = document.getElementById('btn-generate');
      const progressSection = document.getElementById('progress-section');
      const progressFill = document.getElementById('progress-fill');
      const progressText = document.getElementById('progress-text');
      const resultsSection = document.getElementById('results-section');
      
      btn.disabled = true;
      btn.textContent = 'Processing...';
      progressSection.classList.remove('hidden');
      resultsSection.classList.add('hidden');
      progressFill.style.width = '0%';
      
      try {
        allResults = [];
        
        if (currentTab === 'txid') {
          const txid = document.getElementById('input-txid').value.trim();
          if (!txid) throw new Error('Please enter a transaction ID');
          if (!/^[a-fA-F0-9]{64}$/.test(txid)) throw new Error('Invalid TXID format (must be 64 hex characters)');
          
          progressText.textContent = 'Fetching transaction...';
          progressFill.style.width = '50%';
          
          const txInfo = await getTransaction(txid);
          const outputCount = txInfo?.vout?.length || 1;
          
          for (let i = 0; i < outputCount; i++) {
            progressText.textContent = `Processing output ${i + 1} of ${outputCount}...`;
            progressFill.style.width = `${50 + (i / outputCount) * 50}%`;
            const envelope = await generateEnvelope(txid, i);
            allResults.push(envelope);
          }
          
        } else if (currentTab === 'address') {
          const address = document.getElementById('input-address').value.trim();
          if (!address) throw new Error('Please enter an address');
          
          progressText.textContent = 'Fetching UTXOs...';
          const utxos = await getAddressUtxos(address);
          
          if (utxos.length === 0) throw new Error('No UTXOs found for this address');
          
          for (let i = 0; i < utxos.length; i++) {
            progressText.textContent = `Processing UTXO ${i + 1} of ${utxos.length}...`;
            progressFill.style.width = `${(i / utxos.length) * 100}%`;
            
            try {
              const envelope = await generateEnvelope(utxos[i].tx_hash, utxos[i].tx_pos);
              envelope.address = address;
              allResults.push(envelope);
            } catch (e) {
              allResults.push({
                txid: utxos[i].tx_hash,
                vout: utxos[i].tx_pos,
                address,
                error: e.message,
                validation: { passed: false, checks: [{ name: 'Generation', pass: false, detail: e.message }] }
              });
            }
            
            if (i < utxos.length - 1) await new Promise(r => setTimeout(r, 200));
          }
          
        } else if (currentTab === 'bulk') {
          const addresses = document.getElementById('input-bulk').value
            .split('\n')
            .map(a => a.trim())
            .filter(a => a.length > 0);
          
          if (addresses.length === 0) throw new Error('Please enter at least one address');
          
          for (let i = 0; i < addresses.length; i++) {
            progressText.textContent = `Processing address ${i + 1} of ${addresses.length}...`;
            progressFill.style.width = `${(i / addresses.length) * 100}%`;
            
            try {
              const utxos = await getAddressUtxos(addresses[i]);
              
              for (let j = 0; j < utxos.length; j++) {
                try {
                  const envelope = await generateEnvelope(utxos[j].tx_hash, utxos[j].tx_pos);
                  envelope.address = addresses[i];
                  allResults.push(envelope);
                } catch (e) {
                  allResults.push({
                    txid: utxos[j].tx_hash,
                    vout: utxos[j].tx_pos,
                    address: addresses[i],
                    error: e.message,
                    validation: { passed: false, checks: [] }
                  });
                }
                
                await new Promise(r => setTimeout(r, 150));
              }
            } catch (e) {
              allResults.push({
                address: addresses[i],
                error: e.message,
                validation: { passed: false, checks: [] }
              });
            }
            
            if (i < addresses.length - 1) await new Promise(r => setTimeout(r, 300));
          }
        }
        
        progressFill.style.width = '100%';
        displayResults();
        
      } catch (e) {
        alert('Error: ' + e.message);
      }
      
      progressSection.classList.add('hidden');
      btn.disabled = false;
      btn.textContent = 'Generate Envelopes';
    }

    function displayResults() {
      const resultsSection = document.getElementById('results-section');
      const envelopeList = document.getElementById('envelope-list');
      const validationSummary = document.getElementById('validation-summary');
      
      const total = allResults.length;
      const withProofs = allResults.filter(r => r.hasProof).length;
      const validationPassed = allResults.filter(r => r.validation?.passed).length;
      const totalBalance = allResults.reduce((sum, r) => sum + (r.satoshis || 0), 0) / 100000000;
      
      document.getElementById('stat-total').textContent = total;
      document.getElementById('stat-valid').textContent = withProofs;
      document.getElementById('stat-balance').textContent = totalBalance.toFixed(8);
      
      // Validation summary
      if (total > 0) {
        const allValid = validationPassed === total;
        validationSummary.innerHTML = `
          <div class="result-box ${allValid ? 'success' : 'warning'}">
            <div class="result-title">${allValid ? '‚úì All Validations Passed' : '‚ö† Some Validations Failed'}</div>
            <ul class="check-list">
              <li class="check-item">
                <span class="check-icon ${validationPassed === total ? 'pass' : 'warn'}">
                  ${validationPassed === total ? '‚úì' : '!'}
                </span>
                ${validationPassed} of ${total} envelopes passed all checks
              </li>
              <li class="check-item">
                <span class="check-icon ${withProofs > 0 ? 'pass' : 'warn'}">
                  ${withProofs > 0 ? '‚úì' : '!'}
                </span>
                ${withProofs} of ${total} have complete merkle proofs
              </li>
            </ul>
          </div>
        `;
      }
      
      // Envelope list
      envelopeList.innerHTML = allResults.map((r, idx) => {
        if (r.error) {
          return `
            <div class="envelope-item" onclick="showEnvelope(${idx})">
              <div class="envelope-header">
                <span class="envelope-txid">${r.txid ? r.txid.slice(0, 12) + '...' : r.address || 'Error'}</span>
                <span class="envelope-status invalid">Error</span>
              </div>
              <div class="envelope-meta">${r.error}</div>
            </div>
          `;
        }
        
        const statusClass = r.validation?.passed ? 'valid' : (r.hasProof ? 'valid' : 'unconfirmed');
        const statusText = r.validation?.passed ? '‚úì Valid' : (r.hasProof ? '‚úì Has Proof' : '‚è≥ Unconfirmed');
        
        return `
          <div class="envelope-item" onclick="showEnvelope(${idx})">
            <div class="envelope-header">
              <span class="envelope-txid">${r.txid.slice(0, 12)}...${r.txid.slice(-6)}:${r.vout}</span>
              <span class="envelope-amount">${((r.satoshis || 0) / 100000000).toFixed(8)} BSV</span>
            </div>
            <div class="envelope-meta">
              ${r.address ? `<span>üìç ${r.address.slice(0, 10)}...</span>` : ''}
              ${r.blockHeight ? `<span>Block ${r.blockHeight}</span>` : ''}
              <span class="envelope-status ${statusClass}">${statusText}</span>
            </div>
          </div>
        `;
      }).join('');
      
      resultsSection.classList.remove('hidden');
    }

    window.showEnvelope = function(idx) {
      currentEnvelope = allResults[idx];
      const modalJson = document.getElementById('modal-json');
      
      // Create clean envelope for display (remove internal validation object)
      const displayEnvelope = { ...currentEnvelope };
      delete displayEnvelope.validation;
      
      modalJson.textContent = JSON.stringify(displayEnvelope, null, 2);
      document.getElementById('modal').classList.remove('hidden');
    };

    window.closeModal = function() {
      document.getElementById('modal').classList.add('hidden');
    };

    window.copyEnvelope = function() {
      if (currentEnvelope) {
        const displayEnvelope = { ...currentEnvelope };
        delete displayEnvelope.validation;
        navigator.clipboard.writeText(JSON.stringify(displayEnvelope, null, 2));
      }
    };

    // Download button
    document.getElementById('btn-download').addEventListener('click', () => {
      if (allResults.length === 0) return;
      
      const cleanResults = allResults.map(r => {
        const clean = { ...r };
        delete clean.validation;
        return clean;
      });
      
      const blob = new Blob([JSON.stringify(cleanResults, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `spv-envelopes-${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
    });

    // Copy button
    document.getElementById('btn-copy').addEventListener('click', () => {
      if (allResults.length === 0) return;
      
      const cleanResults = allResults.map(r => {
        const clean = { ...r };
        delete clean.validation;
        return clean;
      });
      
      navigator.clipboard.writeText(JSON.stringify(cleanResults, null, 2));
      document.getElementById('btn-copy').textContent = 'Copied!';
      setTimeout(() => document.getElementById('btn-copy').textContent = 'Copy to Clipboard', 2000);
    });

    // Close modal on outside click
    document.getElementById('modal').addEventListener('click', (e) => {
      if (e.target.id === 'modal') closeModal();
    });

    // ==========================================
    // Page Integrity Hash
    // ==========================================
    function computePageIntegrity() {
      const valueEl = document.getElementById('integrity-value');
      
      try {
        let pageSource = document.documentElement.outerHTML;
        pageSource = pageSource.replace(
          /<code id="integrity-value"[^>]*>[^<]*<\/code>/g,
          '<code id="integrity-value">HASH_PLACEHOLDER</code>'
        );
        
        const encoder = new TextEncoder();
        const data = encoder.encode(pageSource);
        const hashBytes = SHA256.hash(data);
        const hashHex = bytesToHex(hashBytes);
        
        const displayHash = hashHex.slice(0, 16) + '...' + hashHex.slice(-8);
        valueEl.textContent = displayHash;
        valueEl.title = 'Full SHA-256: ' + hashHex + '\nClick to copy';
        valueEl.onclick = () => navigator.clipboard.writeText(hashHex);
        
        console.log('Page integrity hash:', hashHex);
      } catch (e) {
        console.error('Failed to compute integrity hash:', e);
        valueEl.textContent = 'Error';
      }
    }

    if (document.readyState === 'complete') {
      computePageIntegrity();
    } else {
      window.addEventListener('load', computePageIntegrity);
    }

  })();
  </script>
</body>
</html>
