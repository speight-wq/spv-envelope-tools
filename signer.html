<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Offline Transaction Signer — SPV Envelope Tools</title>
  <style>
    :root { --bg: #fff; --surface: #f8f9fa; --border: #dee2e6; --text: #212529; --text-2: #495057; --text-3: #868e96; --accent: #228be6; --success: #2f9e44; --success-bg: #d3f9d8; --warning: #e67700; --warning-bg: #fff3bf; --danger: #e03131; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); line-height: 1.6; padding: 32px 24px; max-width: 720px; margin: 0 auto; }
    h1 { font-size: 1.75rem; font-weight: 600; margin-bottom: 8px; }
    .subtitle { color: var(--text-2); margin-bottom: 24px; }
    .subtitle a { color: var(--accent); text-decoration: none; }
    .notice { background: var(--warning-bg); border: 2px solid var(--warning); border-radius: 8px; padding: 16px 20px; margin-bottom: 32px; }
    .notice-title { font-weight: 600; margin-bottom: 4px; }
    .notice-text { color: var(--text-2); font-size: 0.95rem; }
    .section { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 24px; margin-bottom: 24px; }
    .section-title { font-size: 1rem; font-weight: 600; margin-bottom: 16px; }
    .step-number { display: inline-block; width: 24px; height: 24px; background: var(--accent); color: white; border-radius: 50%; text-align: center; line-height: 24px; font-size: 0.8rem; font-weight: 600; margin-right: 8px; }
    .field { margin-bottom: 16px; }
    .label { display: block; font-size: 0.875rem; font-weight: 500; color: var(--text-2); margin-bottom: 6px; }
    .input { width: 100%; padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-family: monospace; font-size: 0.875rem; }
    .input:focus { outline: none; border-color: var(--accent); }
    textarea.input { min-height: 100px; resize: vertical; }
    .hint { font-size: 0.8rem; color: var(--text-3); margin-top: 4px; }
    .hint a { color: var(--accent); }
    .checkbox-row { display: flex; align-items: center; gap: 8px; margin-top: 8px; }
    .checkbox-row input { width: 16px; height: 16px; }
    .checkbox-row label { font-size: 0.875rem; color: var(--text-2); cursor: pointer; }
    .btn { display: inline-block; padding: 10px 20px; border-radius: 6px; font-size: 0.875rem; font-weight: 500; cursor: pointer; border: none; }
    .btn-primary { background: var(--accent); color: white; }
    .btn-secondary { background: var(--bg); color: var(--text); border: 1px solid var(--border); }
    .btn-row { display: flex; gap: 8px; margin-top: 16px; }
    .info-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border); font-size: 0.875rem; }
    .info-row:last-child { border-bottom: none; }
    .info-label { color: var(--text-3); }
    .info-value { font-family: monospace; text-align: right; word-break: break-all; max-width: 60%; }
    .result-box { background: var(--success-bg); border: 2px solid var(--success); border-radius: 8px; padding: 20px; margin-top: 20px; }
    .result-title { font-weight: 600; color: var(--success); margin-bottom: 12px; font-size: 1.1rem; }
    .error-box { background: #ffe3e3; border: 2px solid var(--danger); border-radius: 8px; padding: 16px; margin-top: 16px; color: var(--danger); }
    .next-steps { background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 20px; margin-top: 20px; }
    .next-steps h3 { font-size: 1rem; margin-bottom: 12px; }
    .next-steps ol { margin-left: 20px; color: var(--text-2); }
    .next-steps li { margin-bottom: 8px; }
    .next-steps a { color: var(--accent); }
    .hidden { display: none !important; }
    .divider { height: 1px; background: var(--border); margin: 16px 0; }
    .quote { background: var(--surface); border-left: 4px solid var(--accent); padding: 16px 20px; margin: 32px 0; font-style: italic; color: var(--text-2); font-size: 0.9rem; }
    .quote-author { font-style: normal; font-weight: 600; color: var(--text); margin-top: 8px; display: block; }
    .confirm-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; }
    .confirm-box { background: var(--bg); border-radius: 12px; padding: 24px; max-width: 400px; width: 90%; box-shadow: 0 4px 24px rgba(0,0,0,0.2); }
    .confirm-title { font-size: 1.1rem; font-weight: 600; margin-bottom: 16px; }
    .confirm-row { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid var(--border); font-size: 0.9rem; }
    .confirm-row:last-of-type { border-bottom: none; }
    .confirm-label { color: var(--text-3); }
    .confirm-value { font-family: monospace; font-weight: 500; text-align: right; max-width: 55%; word-break: break-all; }
    .confirm-value.address { font-size: 0.75rem; }
    .confirm-buttons { display: flex; gap: 12px; margin-top: 20px; }
    .confirm-buttons .btn { flex: 1; }
    .network-warning { background: var(--bg); border-radius: 12px; padding: 24px; max-width: 420px; width: 90%; box-shadow: 0 4px 24px rgba(0,0,0,0.2); }
    .network-warning-icon { font-size: 2.5rem; margin-bottom: 12px; }
    .network-warning-title { font-size: 1.2rem; font-weight: 600; color: var(--danger); margin-bottom: 12px; }
    .network-warning-text { color: var(--text-2); font-size: 0.95rem; margin-bottom: 20px; line-height: 1.6; }
    .network-warning-buttons { display: flex; gap: 12px; }
    .network-warning-buttons .btn { flex: 1; }
    .btn-danger { background: var(--danger); color: white; }
    .status-bar { background: var(--success-bg); border: 1px solid var(--success); color: var(--success); padding: 8px 16px; border-radius: 6px; margin-bottom: 24px; font-size: 0.875rem; display: flex; align-items: center; gap: 8px; }
    .status-bar.offline { background: var(--success-bg); border-color: var(--success); color: var(--success); }
    .status-bar.online { background: #ffe3e3; border-color: var(--danger); color: var(--danger); }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; }
    .status-bar.offline .status-dot { background: var(--success); }
    .status-bar.online .status-dot { background: var(--danger); }
    .integrity-display { margin-top: 8px; padding: 8px 12px; background: var(--surface); border-radius: 4px; font-size: 0.75rem; }
    .integrity-label { color: var(--text-3); }
    .integrity-display code { color: var(--text); font-family: monospace; margin-left: 4px; user-select: all; }
    .integrity-status { margin-left: 8px; }
    .integrity-status.verified { color: var(--success); }
    .integrity-status.computing { color: var(--text-3); }
    .qr-container { background: var(--bg); border-radius: 12px; padding: 24px; max-width: 400px; width: 90%; box-shadow: 0 4px 24px rgba(0,0,0,0.2); text-align: center; }
    .qr-title { font-size: 1.1rem; font-weight: 600; margin-bottom: 4px; }
    .qr-subtitle { color: var(--text-3); font-size: 0.85rem; margin-bottom: 16px; }
    .qr-container canvas { display: block; margin: 0 auto 16px; max-width: 100%; border: 1px solid var(--border); border-radius: 8px; }
    .qr-info { font-size: 0.75rem; color: var(--text-3); margin-bottom: 16px; }
    .qr-buttons { display: flex; gap: 12px; margin-bottom: 16px; }
    .qr-buttons .btn { flex: 1; }
    .qr-instructions { text-align: left; font-size: 0.8rem; color: var(--text-2); background: var(--surface); padding: 12px; border-radius: 6px; line-height: 1.6; }
    .qr-instructions a { color: var(--accent); }
    footer { text-align: center; color: var(--text-3); font-size: 0.8rem; margin-top: 48px; padding-top: 24px; border-top: 1px solid var(--border); }
    footer a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <h1>Offline Transaction Signer</h1>
  <p class="subtitle">Sign BSV transactions without internet. Uses envelopes from the <a href="generator.html">SPV Envelope Generator</a>.</p>

  <div id="network-status" class="status-bar offline">
    <span class="status-dot"></span>
    <span id="network-status-text">Checking network status...</span>
  </div>

  <div class="notice">
    <div class="notice-title">Security Notice</div>
    <div class="notice-text">This page works completely offline. For maximum security, disconnect from the internet before entering your private key. Your key is never transmitted — all signing happens locally in your browser. Close this tab after use.</div>
  </div>

  <div class="section">
    <div class="section-title"><span class="step-number">1</span>Load SPV Envelope</div>
    <div class="field">
      <label class="label">Paste your SPV envelope JSON</label>
      <textarea class="input" id="envelope-input" placeholder='{"txid": "...", "rawTx": "...", "vout": 0, "value": 0.001}'></textarea>
      <div class="hint">Contains your UTXO proof. Get it from the <a href="generator.html">envelope generator</a>.</div>
    </div>
    <button class="btn btn-secondary" onclick="parseEnvelope()">Parse Envelope</button>
    <div id="envelope-info" class="hidden">
      <div class="divider"></div>
      <div class="info-row"><span class="info-label">Transaction ID</span><span class="info-value" id="info-txid"></span></div>
      <div class="info-row"><span class="info-label">Output Index</span><span class="info-value" id="info-vout"></span></div>
      <div class="info-row"><span class="info-label">Value</span><span class="info-value" id="info-value"></span></div>
    </div>
  </div>

  <div class="section">
    <div class="section-title"><span class="step-number">2</span>Enter Private Key</div>
    <div class="field">
      <label class="label">Private Key (WIF format)</label>
      <input type="password" class="input" id="private-key" placeholder="Starts with K, L, or 5" autocomplete="off">
      <div class="hint">The key that controls the coins in your envelope.</div>
      <div class="checkbox-row"><input type="checkbox" id="show-key" onchange="document.getElementById('private-key').type = this.checked ? 'text' : 'password'"><label for="show-key">Show private key</label></div>
    </div>
    <button class="btn btn-secondary" onclick="verifyKey()">Verify Key</button>
    <div id="key-info" class="hidden">
      <div class="divider"></div>
      <div class="info-row"><span class="info-label">Address</span><span class="info-value" id="info-address"></span></div>
      <div class="info-row"><span class="info-label">Format</span><span class="info-value" id="info-format"></span></div>
    </div>
  </div>

  <div class="section">
    <div class="section-title"><span class="step-number">3</span>Set Destination</div>
    <div class="field"><label class="label">Destination Address</label><input type="text" class="input" id="dest-address" placeholder="1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2"></div>
    <div class="field"><label class="label">Amount to Send (BSV)</label><input type="text" class="input" id="send-amount" placeholder="Leave empty to send all (minus fee)"></div>
    <div class="field"><label class="label">Fee Rate (satoshis per byte)</label><input type="text" class="input" id="fee-rate" value="1"><div class="hint">1 sat/byte is typically sufficient for BSV.</div></div>
  </div>

  <div class="section">
    <div class="section-title"><span class="step-number">4</span>Sign Transaction</div>
    <p style="color: var(--text-2); font-size: 0.9rem; margin-bottom: 16px;">Creates a signed transaction. You'll broadcast it when you're back online.</p>
    <button class="btn btn-primary" onclick="signTransaction()">Sign Transaction</button>
    
    <div id="tx-result" class="hidden">
      <div class="result-box">
        <div class="result-title">Transaction Signed Successfully</div>
        <div class="info-row"><span class="info-label">New Transaction ID</span><span class="info-value" id="result-txid"></span></div>
        <div class="info-row"><span class="info-label">Size</span><span class="info-value" id="result-size"></span></div>
        <div class="info-row"><span class="info-label">Fee</span><span class="info-value" id="result-fee"></span></div>
        <div class="divider"></div>
        <div class="field">
          <label class="label">Signed Transaction (Raw Hex)</label>
          <textarea class="input" id="result-hex" readonly style="min-height: 120px; background: white;"></textarea>
          <div class="hint">Save this hex string. Paste it into a broadcast service when online.</div>
        </div>
        <div class="btn-row">
          <button class="btn btn-secondary" onclick="copyTx()">Copy to Clipboard</button>
          <button class="btn btn-secondary" onclick="downloadTx()">Download as File</button>
          <button class="btn btn-primary" onclick="showQRCode()">Show QR Code</button>
        </div>
      </div>
      <div class="next-steps">
        <h3>What To Do Next</h3>
        <ol>
          <li><strong>Save the signed transaction</strong> — Copy it or download the file.</li>
          <li><strong>When you have internet</strong> — Go to a broadcast service.</li>
          <li><strong>Broadcast options:</strong>
            <ul style="margin-top: 8px; margin-left: 16px; list-style: disc;">
              <li><a href="https://whatsonchain.com/broadcast" target="_blank">WhatsOnChain Broadcast</a></li>
            </ul>
          </li>
          <li><strong>Once confirmed</strong> — Your transaction is on the blockchain.</li>
        </ol>
      </div>
    </div>
    <div id="tx-error" class="error-box hidden"></div>
  </div>

  <div class="quote">
    "A user only needs to keep a copy of the block headers of the longest proof-of-work chain... and obtain the Merkle branch linking the transaction to the block it's timestamped in. He can't check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it."
    <span class="quote-author">— Satoshi Nakamoto, Bitcoin Whitepaper (2008)</span>
  </div>

  <footer>
    <a href="https://github.com/speight-wq/spv-envelope-tools">SPV Envelope Tools</a><br>
    <a href="generator.html">Generator</a> · <a href="verifier.html">Verifier</a> · Signer<br><br>
    All code runs locally. Your keys never leave this page.<br><br>
    <div id="integrity-hash" class="integrity-display">
      <span class="integrity-label">Page Integrity SHA-256:</span>
      <code id="integrity-value">Computing...</code>
      <span id="integrity-status"></span>
    </div>
  </footer>

  <div id="confirm-modal" class="confirm-overlay hidden">
    <div class="confirm-box">
      <div class="confirm-title">Confirm Transaction</div>
      <div class="confirm-row"><span class="confirm-label">From</span><span class="confirm-value address" id="confirm-from"></span></div>
      <div class="confirm-row"><span class="confirm-label">To</span><span class="confirm-value address" id="confirm-to"></span></div>
      <div class="confirm-row"><span class="confirm-label">Amount</span><span class="confirm-value" id="confirm-amount"></span></div>
      <div class="confirm-row"><span class="confirm-label">Fee</span><span class="confirm-value" id="confirm-fee"></span></div>
      <div class="confirm-row"><span class="confirm-label">Change</span><span class="confirm-value" id="confirm-change"></span></div>
      <div class="confirm-buttons">
        <button class="btn btn-secondary" onclick="cancelSign()">Cancel</button>
        <button class="btn btn-primary" onclick="confirmSign()">Sign</button>
      </div>
    </div>
  </div>

  <div id="network-modal" class="confirm-overlay hidden">
    <div class="network-warning">
      <div class="network-warning-icon">⚠️</div>
      <div class="network-warning-title">Network Connection Detected</div>
      <div class="network-warning-text">
        Your device appears to be connected to the internet.<br><br>
        For maximum security, disconnect from WiFi and mobile data before entering your private key. This ensures your key cannot be transmitted.
      </div>
      <div class="network-warning-buttons">
        <button class="btn btn-secondary" onclick="dismissNetworkWarning()">Continue Anyway</button>
        <button class="btn btn-primary" onclick="checkNetworkAgain()">I've Disconnected</button>
      </div>
    </div>
  </div>

  <div id="qr-modal" class="confirm-overlay hidden">
    <div class="qr-container">
      <div class="qr-title">Signed Transaction QR Code</div>
      <div class="qr-subtitle">Scan with your phone to broadcast</div>
      <canvas id="qr-canvas"></canvas>
      <div class="qr-info" id="qr-info"></div>
      <div class="qr-buttons">
        <button class="btn btn-secondary" onclick="closeQRCode()">Close</button>
        <button class="btn btn-primary" onclick="saveQRCode()">Save as Image</button>
      </div>
      <div class="qr-instructions">
        <strong>Air-Gap Workflow:</strong><br>
        1. Scan this QR with your phone<br>
        2. Paste the hex into <a href="https://whatsonchain.com/broadcast" target="_blank">WhatsOnChain</a><br>
        3. Broadcast the transaction
      </div>
    </div>
  </div>

  <script>
  (function() {
    'use strict';
    
    // ==========================================
    // QR Code Generator (Pure JS, No Dependencies)
    // Based on qr.js - Public Domain
    // Supports alphanumeric mode for hex strings
    // ==========================================
    const QRCode = (function() {
      // QR Code configuration tables
      const EC_CODEWORDS = [
        // L, M, Q, H error correction levels - codewords per block
        [7,10,13,17,20,26,36,44,52,60,69,76,84,98,106,122,140,158,180,196,224,252,270,300,312,336,360,390,420,450,480,510,540,570,600,630,660,720,750,780],
        [10,16,22,28,36,44,56,68,80,96,112,128,144,168,192,224,256,288,320,360,400,448,504,560,624,688,752,816,896,960,1024,1088,1152,1216,1280,1344,1408,1536,1600,1664],
        [13,22,36,52,72,96,124,156,188,224,264,308,352,408,468,540,612,692,776,860,952,1048,1152,1256,1372,1496,1620,1756,1892,2028,2164,2300,2436,2572,2708,2844,2980,3176,3332,3488],
        [17,28,44,64,88,112,144,176,208,248,288,328,376,424,476,532,588,652,716,788,860,936,1016,1096,1184,1272,1360,1448,1536,1632,1728,1824,1920,2016,2112,2208,2304,2464,2560,2656]
      ];
      
      const ALPHANUM = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';
      
      // Calculate minimum QR version needed for data length
      function getMinVersion(dataLen, ecLevel) {
        const capacities = [
          [25,47,77,114,154,195,244,293,346,404,466,532,604,674,746,813,919,969,1056,1108,1228,1286,1425,1501,1581,1677,1782,1897,2022,2157,2301,2361,2524,2625,2735,2927,3057,3283,3517,3669],
          [20,38,61,90,122,154,193,230,271,321,370,416,470,531,574,644,702,742,823,890,963,1041,1094,1172,1263,1322,1429,1499,1618,1700,1787,1867,1966,2071,2181,2298,2420,2520,2640,2725],
          [16,29,47,67,87,108,134,163,195,224,264,297,343,393,425,485,515,565,611,661,715,751,805,868,908,982,1030,1112,1168,1228,1283,1351,1423,1499,1579,1663,1751,1817,1911,1989],
          [10,20,35,50,64,84,93,122,143,174,200,227,259,296,319,365,393,421,465,512,568,614,664,718,754,808,871,911,985,1033,1115,1171,1231,1286,1354,1426,1502,1582,1666,1714]
        ];
        for (let v = 0; v < 40; v++) {
          if (capacities[ecLevel][v] >= dataLen) return v + 1;
        }
        return 40;
      }
      
      // Reed-Solomon error correction
      function rsGenPoly(nsym) {
        let g = [1];
        for (let i = 0; i < nsym; i++) {
          const ng = new Array(g.length + 1).fill(0);
          for (let j = 0; j < g.length; j++) {
            ng[j] ^= g[j];
            ng[j + 1] ^= gfMul(g[j], gfExp[i]);
          }
          g = ng;
        }
        return g;
      }
      
      // Galois field multiplication tables
      const gfExp = new Array(512);
      const gfLog = new Array(256);
      (function() {
        let x = 1;
        for (let i = 0; i < 255; i++) {
          gfExp[i] = x;
          gfLog[x] = i;
          x <<= 1;
          if (x & 0x100) x ^= 0x11d;
        }
        for (let i = 255; i < 512; i++) gfExp[i] = gfExp[i - 255];
      })();
      
      function gfMul(x, y) {
        if (x === 0 || y === 0) return 0;
        return gfExp[gfLog[x] + gfLog[y]];
      }
      
      function rsEncode(data, nsym) {
        const gen = rsGenPoly(nsym);
        const res = new Array(data.length + nsym).fill(0);
        for (let i = 0; i < data.length; i++) res[i] = data[i];
        for (let i = 0; i < data.length; i++) {
          const coef = res[i];
          if (coef !== 0) {
            for (let j = 0; j < gen.length; j++) {
              res[i + j] ^= gfMul(gen[j], coef);
            }
          }
        }
        return res.slice(data.length);
      }
      
      // Encode alphanumeric data (for hex strings)
      function encodeAlphanumeric(str) {
        str = str.toUpperCase();
        const bits = [];
        for (let i = 0; i < str.length; i += 2) {
          if (i + 1 < str.length) {
            const val = ALPHANUM.indexOf(str[i]) * 45 + ALPHANUM.indexOf(str[i + 1]);
            for (let b = 10; b >= 0; b--) bits.push((val >> b) & 1);
          } else {
            const val = ALPHANUM.indexOf(str[i]);
            for (let b = 5; b >= 0; b--) bits.push((val >> b) & 1);
          }
        }
        return bits;
      }
      
      // Create QR code matrix
      function createMatrix(version) {
        const size = version * 4 + 17;
        const matrix = [];
        for (let i = 0; i < size; i++) {
          matrix[i] = new Array(size).fill(null);
        }
        return matrix;
      }
      
      // Add finder patterns
      function addFinderPatterns(matrix) {
        const size = matrix.length;
        const pattern = [
          [1,1,1,1,1,1,1],
          [1,0,0,0,0,0,1],
          [1,0,1,1,1,0,1],
          [1,0,1,1,1,0,1],
          [1,0,1,1,1,0,1],
          [1,0,0,0,0,0,1],
          [1,1,1,1,1,1,1]
        ];
        const positions = [[0, 0], [size - 7, 0], [0, size - 7]];
        for (const [row, col] of positions) {
          for (let r = 0; r < 7; r++) {
            for (let c = 0; c < 7; c++) {
              if (row + r < size && col + c < size) {
                matrix[row + r][col + c] = pattern[r][c];
              }
            }
          }
        }
        // Separators
        for (let i = 0; i < 8; i++) {
          if (i < size) {
            matrix[7][i] = 0; matrix[i][7] = 0;
            matrix[7][size - 1 - i] = 0; matrix[i][size - 8] = 0;
            matrix[size - 8][i] = 0; matrix[size - 1 - i][7] = 0;
          }
        }
      }
      
      // Add timing patterns
      function addTimingPatterns(matrix) {
        const size = matrix.length;
        for (let i = 8; i < size - 8; i++) {
          const bit = (i + 1) % 2;
          if (matrix[6][i] === null) matrix[6][i] = bit;
          if (matrix[i][6] === null) matrix[i][6] = bit;
        }
      }
      
      // Add alignment patterns
      function addAlignmentPatterns(matrix, version) {
        if (version < 2) return;
        const positions = getAlignmentPositions(version);
        const pattern = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]];
        for (const row of positions) {
          for (const col of positions) {
            if (matrix[row][col] === null) {
              for (let r = -2; r <= 2; r++) {
                for (let c = -2; c <= 2; c++) {
                  matrix[row + r][col + c] = pattern[r + 2][c + 2];
                }
              }
            }
          }
        }
      }
      
      function getAlignmentPositions(version) {
        if (version === 1) return [];
        const intervals = [0, 0, 18, 22, 26, 30, 34, 22, 24, 26, 28, 30, 32, 34, 26, 26, 26, 30, 30, 30, 34, 28, 26, 30, 28, 32, 30, 34, 26, 30, 26, 30, 34, 30, 34, 30, 34, 30, 34, 34, 34];
        const size = version * 4 + 17;
        const step = intervals[version];
        const positions = [6];
        let pos = size - 7;
        while (pos > 6) {
          positions.unshift(pos);
          pos -= step;
        }
        return positions;
      }
      
      // Add format info
      function addFormatInfo(matrix, ecLevel, mask) {
        const size = matrix.length;
        const formatBits = getFormatBits(ecLevel, mask);
        for (let i = 0; i < 6; i++) {
          matrix[8][i] = formatBits[i];
          matrix[i][8] = formatBits[14 - i];
        }
        matrix[8][7] = formatBits[6];
        matrix[8][8] = formatBits[7];
        matrix[7][8] = formatBits[8];
        for (let i = 0; i < 6; i++) {
          matrix[8][size - 1 - i] = formatBits[14 - i];
          matrix[size - 1 - i][8] = formatBits[i];
        }
        matrix[8][size - 7] = formatBits[8];
        matrix[8][size - 8] = formatBits[7];
        matrix[size - 7][8] = 1; // Dark module
      }
      
      function getFormatBits(ecLevel, mask) {
        const ecBits = [1, 0, 3, 2][ecLevel];
        let data = (ecBits << 3) | mask;
        let rem = data;
        for (let i = 0; i < 10; i++) {
          rem = (rem << 1) ^ ((rem >> 9) * 0x537);
        }
        const bits = ((data << 10) | rem) ^ 0x5412;
        const result = [];
        for (let i = 14; i >= 0; i--) result.push((bits >> i) & 1);
        return result;
      }
      
      // Add version info (for version 7+)
      function addVersionInfo(matrix, version) {
        if (version < 7) return;
        const size = matrix.length;
        let rem = version;
        for (let i = 0; i < 12; i++) {
          rem = (rem << 1) ^ ((rem >> 11) * 0x1f25);
        }
        const bits = (version << 12) | rem;
        for (let i = 0; i < 18; i++) {
          const bit = (bits >> i) & 1;
          const row = Math.floor(i / 3);
          const col = i % 3 + size - 11;
          matrix[row][col] = bit;
          matrix[col][row] = bit;
        }
      }
      
      // Place data bits
      function placeData(matrix, dataBits) {
        const size = matrix.length;
        let bitIndex = 0;
        let up = true;
        for (let col = size - 1; col >= 0; col -= 2) {
          if (col === 6) col = 5;
          for (let i = 0; i < size; i++) {
            const row = up ? size - 1 - i : i;
            for (let j = 0; j < 2; j++) {
              const c = col - j;
              if (matrix[row][c] === null) {
                matrix[row][c] = bitIndex < dataBits.length ? dataBits[bitIndex++] : 0;
              }
            }
          }
          up = !up;
        }
      }
      
      // Apply mask pattern
      function applyMask(matrix, mask) {
        const size = matrix.length;
        const maskFn = [
          (r, c) => (r + c) % 2 === 0,
          (r, c) => r % 2 === 0,
          (r, c) => c % 3 === 0,
          (r, c) => (r + c) % 3 === 0,
          (r, c) => (Math.floor(r / 2) + Math.floor(c / 3)) % 2 === 0,
          (r, c) => (r * c) % 2 + (r * c) % 3 === 0,
          (r, c) => ((r * c) % 2 + (r * c) % 3) % 2 === 0,
          (r, c) => ((r + c) % 2 + (r * c) % 3) % 2 === 0
        ][mask];
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            if (matrix[r][c] !== null && isDataModule(r, c, size)) {
              if (maskFn(r, c)) matrix[r][c] ^= 1;
            }
          }
        }
      }
      
      function isDataModule(row, col, size) {
        // Check if module is in data area (not finder, timing, etc.)
        if (row < 9 && col < 9) return false;
        if (row < 9 && col >= size - 8) return false;
        if (row >= size - 8 && col < 9) return false;
        if (row === 6 || col === 6) return false;
        return true;
      }
      
      // Main QR generation function
      function generate(text, ecLevel = 0) {
        const data = text.toUpperCase();
        const version = getMinVersion(data.length, ecLevel);
        const size = version * 4 + 17;
        
        // Build data codewords
        const bits = [];
        // Mode indicator (alphanumeric = 0010)
        bits.push(0, 0, 1, 0);
        // Character count
        const ccBits = version < 10 ? 9 : (version < 27 ? 11 : 13);
        for (let i = ccBits - 1; i >= 0; i--) bits.push((data.length >> i) & 1);
        // Data
        bits.push(...encodeAlphanumeric(data));
        // Terminator
        const capacity = getDataCapacity(version, ecLevel);
        while (bits.length < capacity * 8 && bits.length < capacity * 8) bits.push(0);
        while (bits.length % 8 !== 0) bits.push(0);
        // Pad codewords
        const padBytes = [0xec, 0x11];
        let padIndex = 0;
        while (bits.length < capacity * 8) {
          for (let i = 7; i >= 0; i--) bits.push((padBytes[padIndex] >> i) & 1);
          padIndex = 1 - padIndex;
        }
        
        // Convert to bytes
        const dataBytes = [];
        for (let i = 0; i < bits.length; i += 8) {
          let byte = 0;
          for (let j = 0; j < 8; j++) byte = (byte << 1) | bits[i + j];
          dataBytes.push(byte);
        }
        
        // Add error correction
        const ecInfo = getECInfo(version, ecLevel);
        const blocks = [];
        let dataIndex = 0;
        for (let i = 0; i < ecInfo.numBlocks; i++) {
          const blockSize = i < ecInfo.numBlocks - ecInfo.numLargeBlocks 
            ? ecInfo.dataPerBlock 
            : ecInfo.dataPerBlock + 1;
          const block = dataBytes.slice(dataIndex, dataIndex + blockSize);
          dataIndex += blockSize;
          const ec = rsEncode(block, ecInfo.ecPerBlock);
          blocks.push({ data: block, ec: ec });
        }
        
        // Interleave
        const finalBits = [];
        const maxDataLen = Math.max(...blocks.map(b => b.data.length));
        for (let i = 0; i < maxDataLen; i++) {
          for (const block of blocks) {
            if (i < block.data.length) {
              for (let j = 7; j >= 0; j--) finalBits.push((block.data[i] >> j) & 1);
            }
          }
        }
        for (let i = 0; i < ecInfo.ecPerBlock; i++) {
          for (const block of blocks) {
            for (let j = 7; j >= 0; j--) finalBits.push((block.ec[i] >> j) & 1);
          }
        }
        
        // Create matrix
        const matrix = createMatrix(version);
        addFinderPatterns(matrix);
        addTimingPatterns(matrix);
        addAlignmentPatterns(matrix, version);
        addVersionInfo(matrix, version);
        
        // Try all masks, pick best
        let bestMatrix = null;
        let bestPenalty = Infinity;
        for (let mask = 0; mask < 8; mask++) {
          const testMatrix = matrix.map(row => [...row]);
          placeData(testMatrix, [...finalBits]);
          applyMask(testMatrix, mask);
          addFormatInfo(testMatrix, ecLevel, mask);
          const penalty = calculatePenalty(testMatrix);
          if (penalty < bestPenalty) {
            bestPenalty = penalty;
            bestMatrix = testMatrix;
          }
        }
        
        return bestMatrix;
      }
      
      function getDataCapacity(version, ecLevel) {
        const total = [26,44,70,100,134,172,196,242,292,346,404,466,532,604,674,746,818,898,984,1072,1168,1264,1360,1456,1552,1648,1744,1856,1972,2092,2216,2340,2464,2596,2728,2868,3008,3148,3288,3432][version - 1];
        const ec = EC_CODEWORDS[ecLevel][version - 1];
        return total - ec;
      }
      
      function getECInfo(version, ecLevel) {
        const ecCodewords = EC_CODEWORDS[ecLevel][version - 1];
        const totalCodewords = [26,44,70,100,134,172,196,242,292,346,404,466,532,604,674,746,818,898,984,1072,1168,1264,1360,1456,1552,1648,1744,1856,1972,2092,2216,2340,2464,2596,2728,2868,3008,3148,3288,3432][version - 1];
        const dataCodewords = totalCodewords - ecCodewords;
        const ecPerBlock = [7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30][version - 1 + ecLevel * 40];
        const numBlocks = Math.ceil(ecCodewords / ecPerBlock);
        const dataPerBlock = Math.floor(dataCodewords / numBlocks);
        const numLargeBlocks = dataCodewords % numBlocks;
        return { ecPerBlock, numBlocks, dataPerBlock, numLargeBlocks };
      }
      
      function calculatePenalty(matrix) {
        // Simplified penalty calculation
        let penalty = 0;
        const size = matrix.length;
        // Rule 1: consecutive same-color modules
        for (let r = 0; r < size; r++) {
          let count = 1;
          for (let c = 1; c < size; c++) {
            if (matrix[r][c] === matrix[r][c - 1]) count++;
            else { if (count >= 5) penalty += count - 2; count = 1; }
          }
          if (count >= 5) penalty += count - 2;
        }
        for (let c = 0; c < size; c++) {
          let count = 1;
          for (let r = 1; r < size; r++) {
            if (matrix[r][c] === matrix[r - 1][c]) count++;
            else { if (count >= 5) penalty += count - 2; count = 1; }
          }
          if (count >= 5) penalty += count - 2;
        }
        return penalty;
      }
      
      // Render to canvas
      function toCanvas(matrix, canvas, scale = 4, margin = 4) {
        const size = matrix.length;
        const totalSize = (size + margin * 2) * scale;
        canvas.width = totalSize;
        canvas.height = totalSize;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, totalSize, totalSize);
        ctx.fillStyle = '#000000';
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            if (matrix[r][c]) {
              ctx.fillRect((c + margin) * scale, (r + margin) * scale, scale, scale);
            }
          }
        }
      }
      
      return { generate, toCanvas };
    })();
    
    // ==========================================
    // SHA-256 Implementation
    // ==========================================
    const SHA256 = (function() {
      const K = new Uint32Array([
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
      ]);

      function hash(data) {
        if (typeof data === 'string') data = hexToBytes(data);
        if (!(data instanceof Uint8Array)) data = new Uint8Array(data);
        
        const msgLen = data.length;
        const totalLen = Math.ceil((msgLen + 9) / 64) * 64;
        const padded = new Uint8Array(totalLen);
        padded.set(data);
        padded[msgLen] = 0x80;
        const view = new DataView(padded.buffer);
        view.setUint32(totalLen - 4, msgLen * 8, false);

        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;
        const W = new Uint32Array(64);

        for (let i = 0; i < padded.length; i += 64) {
          for (let j = 0; j < 16; j++) {
            W[j] = (padded[i + j * 4] << 24) | (padded[i + j * 4 + 1] << 16) | 
                   (padded[i + j * 4 + 2] << 8) | padded[i + j * 4 + 3];
          }
          for (let j = 16; j < 64; j++) {
            const s0 = ((W[j-15] >>> 7) | (W[j-15] << 25)) ^ ((W[j-15] >>> 18) | (W[j-15] << 14)) ^ (W[j-15] >>> 3);
            const s1 = ((W[j-2] >>> 17) | (W[j-2] << 15)) ^ ((W[j-2] >>> 19) | (W[j-2] << 13)) ^ (W[j-2] >>> 10);
            W[j] = (W[j-16] + s0 + W[j-7] + s1) >>> 0;
          }

          let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7;
          for (let j = 0; j < 64; j++) {
            const S1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
            const ch = (e & f) ^ (~e & g);
            const t1 = (h + S1 + ch + K[j] + W[j]) >>> 0;
            const S0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
            const maj = (a & b) ^ (a & c) ^ (b & c);
            const t2 = (S0 + maj) >>> 0;
            h = g; g = f; f = e; e = (d + t1) >>> 0;
            d = c; c = b; b = a; a = (t1 + t2) >>> 0;
          }
          h0 = (h0 + a) >>> 0; h1 = (h1 + b) >>> 0; h2 = (h2 + c) >>> 0; h3 = (h3 + d) >>> 0;
          h4 = (h4 + e) >>> 0; h5 = (h5 + f) >>> 0; h6 = (h6 + g) >>> 0; h7 = (h7 + h) >>> 0;
        }

        const result = new Uint8Array(32);
        const rv = new DataView(result.buffer);
        rv.setUint32(0, h0, false); rv.setUint32(4, h1, false);
        rv.setUint32(8, h2, false); rv.setUint32(12, h3, false);
        rv.setUint32(16, h4, false); rv.setUint32(20, h5, false);
        rv.setUint32(24, h6, false); rv.setUint32(28, h7, false);
        return result;
      }

      return { hash };
    })();

    // ==========================================
    // HMAC-SHA256 (Required for RFC 6979)
    // ==========================================
    function hmacSha256(key, data) {
      if (typeof key === 'string') key = hexToBytes(key);
      if (typeof data === 'string') data = hexToBytes(data);
      
      const blockSize = 64;
      
      // If key is longer than block size, hash it
      if (key.length > blockSize) {
        key = SHA256.hash(key);
      }
      
      // Pad key to block size
      const paddedKey = new Uint8Array(blockSize);
      paddedKey.set(key);
      
      // Create inner and outer padded keys
      const ipad = new Uint8Array(blockSize);
      const opad = new Uint8Array(blockSize);
      for (let i = 0; i < blockSize; i++) {
        ipad[i] = paddedKey[i] ^ 0x36;
        opad[i] = paddedKey[i] ^ 0x5c;
      }
      
      // Inner hash: H(ipad || data)
      const innerData = new Uint8Array(blockSize + data.length);
      innerData.set(ipad);
      innerData.set(data, blockSize);
      const innerHash = SHA256.hash(innerData);
      
      // Outer hash: H(opad || innerHash)
      const outerData = new Uint8Array(blockSize + 32);
      outerData.set(opad);
      outerData.set(innerHash, blockSize);
      
      return SHA256.hash(outerData);
    }

    // ==========================================
    // RIPEMD-160 Implementation
    // ==========================================
    const RIPEMD160 = (function() {
      function hash(data) {
        if (typeof data === 'string') data = hexToBytes(data);
        
        const msgLen = data.length;
        const totalLen = Math.ceil((msgLen + 9) / 64) * 64;
        const padded = new Uint8Array(totalLen);
        padded.set(data);
        padded[msgLen] = 0x80;
        new DataView(padded.buffer).setUint32(totalLen - 8, msgLen * 8, true);

        let h0 = 0x67452301, h1 = 0xefcdab89, h2 = 0x98badcfe, h3 = 0x10325476, h4 = 0xc3d2e1f0;

        const r = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13];
        const rp = [5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11];
        const s = [11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6];
        const sp = [8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11];

        function f(j, x, y, z) {
          if (j < 16) return x ^ y ^ z;
          if (j < 32) return (x & y) | (~x & z);
          if (j < 48) return (x | ~y) ^ z;
          if (j < 64) return (x & z) | (y & ~z);
          return x ^ (y | ~z);
        }
        function K(j) { return j < 16 ? 0 : j < 32 ? 0x5a827999 : j < 48 ? 0x6ed9eba1 : j < 64 ? 0x8f1bbcdc : 0xa953fd4e; }
        function Kp(j) { return j < 16 ? 0x50a28be6 : j < 32 ? 0x5c4dd124 : j < 48 ? 0x6d703ef3 : j < 64 ? 0x7a6d76e9 : 0; }
        function rotl(x, n) { return ((x << n) | (x >>> (32 - n))) >>> 0; }

        for (let i = 0; i < padded.length; i += 64) {
          const X = [];
          for (let j = 0; j < 16; j++) {
            X[j] = padded[i + j * 4] | (padded[i + j * 4 + 1] << 8) | (padded[i + j * 4 + 2] << 16) | (padded[i + j * 4 + 3] << 24);
          }

          let al = h0, bl = h1, cl = h2, dl = h3, el = h4;
          let ar = h0, br = h1, cr = h2, dr = h3, er = h4;

          for (let j = 0; j < 80; j++) {
            let tl = (al + f(j, bl, cl, dl) + X[r[j]] + K(j)) >>> 0;
            tl = (rotl(tl, s[j]) + el) >>> 0;
            al = el; el = dl; dl = rotl(cl, 10); cl = bl; bl = tl;

            let tr = (ar + f(79 - j, br, cr, dr) + X[rp[j]] + Kp(j)) >>> 0;
            tr = (rotl(tr, sp[j]) + er) >>> 0;
            ar = er; er = dr; dr = rotl(cr, 10); cr = br; br = tr;
          }

          const t = (h1 + cl + dr) >>> 0;
          h1 = (h2 + dl + er) >>> 0; h2 = (h3 + el + ar) >>> 0;
          h3 = (h4 + al + br) >>> 0; h4 = (h0 + bl + cr) >>> 0; h0 = t;
        }

        const result = new Uint8Array(20);
        const view = new DataView(result.buffer);
        view.setUint32(0, h0, true); view.setUint32(4, h1, true);
        view.setUint32(8, h2, true); view.setUint32(12, h3, true);
        view.setUint32(16, h4, true);
        return result;
      }
      return { hash };
    })();

    // ==========================================
    // Utility Functions
    // ==========================================
    function hexToBytes(hex) {
      hex = hex.replace(/^0x/, '');
      if (hex.length % 2) hex = '0' + hex;
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
      }
      return bytes;
    }

    function bytesToHex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function reverseHex(hex) {
      return bytesToHex(hexToBytes(hex).reverse());
    }

    function hash256(data) {
      return SHA256.hash(SHA256.hash(data));
    }

    function hash160(data) {
      return RIPEMD160.hash(SHA256.hash(data));
    }

    // ==========================================
    // BigInt Helpers for secp256k1
    // ==========================================
    function bytesToBigInt(bytes) {
      return BigInt('0x' + bytesToHex(bytes));
    }

    function bigIntToBytes(num, length = 32) {
      let hex = num.toString(16);
      if (hex.length % 2) hex = '0' + hex;
      while (hex.length < length * 2) hex = '00' + hex;
      if (hex.length > length * 2) hex = hex.slice(-length * 2);
      return hexToBytes(hex);
    }

    // ==========================================
    // SECP256K1 with RFC 6979
    // ==========================================
    const SECP256K1 = (function() {
      const P = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F');
      const N = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');
      const Gx = BigInt('0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798');
      const Gy = BigInt('0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8');

      function mod(a, m = P) {
        const result = a % m;
        return result >= 0n ? result : result + m;
      }

      function modInverse(a, m = P) {
        a = mod(a, m);  // Reduce a first
        let [old_r, r] = [a, m];
        let [old_s, s] = [1n, 0n];
        while (r !== 0n) {
          const q = old_r / r;
          [old_r, r] = [r, old_r - q * r];
          [old_s, s] = [s, old_s - q * s];
        }
        return mod(old_s, m);
      }

      function pointAdd(p1, p2) {
        if (p1 === null) return p2;
        if (p2 === null) return p1;
        const [x1, y1] = p1;
        const [x2, y2] = p2;
        if (x1 === x2 && y1 !== y2) return null;

        let lambda;
        if (x1 === x2) {
          // Point doubling: lambda = (3*x1^2) / (2*y1)
          lambda = mod(3n * x1 * x1 * modInverse(2n * y1, P), P);
        } else {
          // Point addition: lambda = (y2-y1) / (x2-x1)
          lambda = mod((y2 - y1) * modInverse(x2 - x1, P), P);
        }
        const x3 = mod(lambda * lambda - x1 - x2, P);
        const y3 = mod(lambda * (x1 - x3) - y1, P);
        return [x3, y3];
      }

      function pointMul(k, p) {
        let result = null;
        let addend = p;
        while (k > 0n) {
          if (k & 1n) result = pointAdd(result, addend);
          addend = pointAdd(addend, addend);
          k >>= 1n;
        }
        return result;
      }

      function getPublicKey(privateKey, compressed = true) {
        const point = pointMul(privateKey, [Gx, Gy]);
        const x = point[0].toString(16).padStart(64, '0');
        const y = point[1].toString(16).padStart(64, '0');
        if (compressed) {
          const prefix = (point[1] & 1n) === 0n ? '02' : '03';
          return prefix + x;
        }
        return '04' + x + y;
      }

      // RFC 6979 Deterministic k Generation
      // Modular exponentiation for point decompression
      function modPow(base, exp, m) {
        let result = 1n;
        base = mod(base, m);
        while (exp > 0n) {
          if (exp & 1n) result = mod(result * base, m);
          exp >>= 1n;
          base = mod(base * base, m);
        }
        return result;
      }

      // Verify signature (self-check before returning)
      function verifySignature(messageHash, r, s, publicKeyHex) {
        try {
          const hashBytes = typeof messageHash === 'string' ? hexToBytes(messageHash) : messageHash;
          const z = bytesToBigInt(hashBytes);
          
          // Parse public key
          const pubBytes = hexToBytes(publicKeyHex);
          let pubPoint;
          if (pubBytes[0] === 0x04 && pubBytes.length === 65) {
            // Uncompressed
            const x = bytesToBigInt(pubBytes.slice(1, 33));
            const y = bytesToBigInt(pubBytes.slice(33, 65));
            pubPoint = [x, y];
          } else if ((pubBytes[0] === 0x02 || pubBytes[0] === 0x03) && pubBytes.length === 33) {
            // Compressed - decompress
            const x = bytesToBigInt(pubBytes.slice(1, 33));
            // y² = x³ + 7 (mod p)
            const xCubed = mod(x * x * x, P);
            const ySquared = mod(xCubed + 7n, P);
            // y = ySquared^((p+1)/4) mod p (since p ≡ 3 mod 4)
            let y = modPow(ySquared, (P + 1n) / 4n, P);
            // Choose correct y based on parity
            const expectedParity = pubBytes[0] === 0x03 ? 1n : 0n;
            if ((y & 1n) !== expectedParity) {
              y = P - y;
            }
            pubPoint = [x, y];
          } else {
            return false;
          }
          
          // Check r, s are in valid range [1, n-1]
          if (r <= 0n || r >= N || s <= 0n || s >= N) return false;
          
          // w = s^-1 mod n
          const w = modInverse(s, N);
          // u1 = z * w mod n
          const u1 = mod(z * w, N);
          // u2 = r * w mod n
          const u2 = mod(r * w, N);
          // point = u1*G + u2*Q
          const u1G = pointMul(u1, [Gx, Gy]);
          const u2Q = pointMul(u2, pubPoint);
          const point = pointAdd(u1G, u2Q);
          
          if (point === null) return false;
          
          // Check r == point.x mod n
          const recoveredR = mod(point[0], N);
          return recoveredR === r;
        } catch (e) {
          console.error('Verify error:', e);
          return false;
        }
      }

      // RFC 6979 compliant signing with proper retry logic
      function sign(messageHash, privateKey) {
        const hashBytes = typeof messageHash === 'string' ? hexToBytes(messageHash) : messageHash;
        const privBytes = bigIntToBytes(privateKey, 32);
        const z = bytesToBigInt(hashBytes);
        
        // RFC 6979 initialization
        let v = new Uint8Array(32).fill(0x01);
        let k = new Uint8Array(32).fill(0x00);
        
        // Step d: K = HMAC_K(V || 0x00 || x || h1)
        let concat = new Uint8Array(32 + 1 + 32 + 32);
        concat.set(v, 0);
        concat[32] = 0x00;
        concat.set(privBytes, 33);
        concat.set(hashBytes, 65);
        k = hmacSha256(k, concat);
        
        // Step e: V = HMAC_K(V)
        v = hmacSha256(k, v);
        
        // Step f: K = HMAC_K(V || 0x01 || x || h1)
        concat = new Uint8Array(32 + 1 + 32 + 32);
        concat.set(v, 0);
        concat[32] = 0x01;
        concat.set(privBytes, 33);
        concat.set(hashBytes, 65);
        k = hmacSha256(k, concat);
        
        // Step g: V = HMAC_K(V)
        v = hmacSha256(k, v);
        
        // Step h: Loop until valid signature
        for (let attempts = 0; attempts < 1000; attempts++) {
          // Generate candidate k
          v = hmacSha256(k, v);
          const kCandidate = bytesToBigInt(v);
          
          // Check k is in valid range
          if (kCandidate > 0n && kCandidate < N) {
            // Calculate r = (k * G).x mod n
            const point = pointMul(kCandidate, [Gx, Gy]);
            const r = mod(point[0], N);
            
            if (r !== 0n) {
              // Calculate s = k^-1 * (z + r * d) mod n
              let s = mod(modInverse(kCandidate, N) * (z + r * privateKey), N);
              
              if (s !== 0n) {
                // Ensure low S (BIP 62 / BIP 146)
                if (s > N / 2n) {
                  s = N - s;
                }
                return { r, s };
              }
            }
          }
          
          // Invalid k, r, or s - update per RFC 6979 section 3.2 step h.3
          concat = new Uint8Array(33);
          concat.set(v, 0);
          concat[32] = 0x00;
          k = hmacSha256(k, concat);
          v = hmacSha256(k, v);
        }
        
        throw new Error('Failed to generate valid signature after 1000 attempts');
      }

      function signatureToDER(r, s) {
        function encodeInt(num) {
          let hex = num.toString(16);
          if (hex.length % 2) hex = '0' + hex;
          if (parseInt(hex[0], 16) >= 8) hex = '00' + hex;
          return hex;
        }
        const rHex = encodeInt(r);
        const sHex = encodeInt(s);
        const rLen = (rHex.length / 2).toString(16).padStart(2, '0');
        const sLen = (sHex.length / 2).toString(16).padStart(2, '0');
        const totalLen = (rHex.length / 2 + sHex.length / 2 + 4).toString(16).padStart(2, '0');
        return '30' + totalLen + '02' + rLen + rHex + '02' + sLen + sHex;
      }

      return { getPublicKey, sign, signatureToDER, verifySignature, N };
    })();

    // ==========================================
    // Base58 Encoding/Decoding
    // ==========================================
    const Base58 = (function() {
      const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      const ALPHABET_MAP = {};
      for (let i = 0; i < ALPHABET.length; i++) {
        ALPHABET_MAP[ALPHABET[i]] = BigInt(i);
      }

      function encode(bytes) {
        if (bytes.length === 0) return '';
        
        let num = bytesToBigInt(bytes);
        let str = '';
        while (num > 0n) {
          str = ALPHABET[Number(num % 58n)] + str;
          num = num / 58n;
        }
        
        for (const byte of bytes) {
          if (byte === 0) str = '1' + str;
          else break;
        }
        return str;
      }

      function decode(str) {
        if (str.length === 0) return new Uint8Array(0);
        
        let num = 0n;
        for (const char of str) {
          if (!(char in ALPHABET_MAP)) throw new Error('Invalid Base58 character: ' + char);
          num = num * 58n + ALPHABET_MAP[char];
        }
        
        let hex = num.toString(16);
        if (hex.length % 2) hex = '0' + hex;
        let bytes = hexToBytes(hex);
        
        let leadingZeros = 0;
        for (const char of str) {
          if (char === '1') leadingZeros++;
          else break;
        }
        
        const result = new Uint8Array(leadingZeros + bytes.length);
        result.set(bytes, leadingZeros);
        return result;
      }

      return { encode, decode };
    })();

    function base58check(data) {
      const checksum = hash256(data).slice(0, 4);
      const combined = new Uint8Array(data.length + 4);
      combined.set(data);
      combined.set(checksum, data.length);
      return Base58.encode(combined);
    }

    function decodeBase58Check(str) {
      const bytes = Base58.decode(str);
      if (bytes.length < 5) throw new Error('Invalid Base58Check: too short');
      
      const data = bytes.slice(0, -4);
      const checksum = bytes.slice(-4);
      const computed = hash256(data).slice(0, 4);
      
      if (bytesToHex(checksum) !== bytesToHex(computed)) {
        throw new Error('Invalid checksum');
      }
      return data;
    }

    // ==========================================
    // Address Validation
    // ==========================================
    function validateAddress(address) {
      try {
        const data = decodeBase58Check(address);
        if (data.length !== 21) return { valid: false, error: 'Invalid length' };
        
        const version = data[0];
        if (version === 0x00) return { valid: true, type: 'P2PKH', network: 'mainnet' };
        if (version === 0x05) return { valid: true, type: 'P2SH', network: 'mainnet' };
        if (version === 0x6f) return { valid: true, type: 'P2PKH', network: 'testnet' };
        if (version === 0xc4) return { valid: true, type: 'P2SH', network: 'testnet' };
        
        return { valid: false, error: 'Unknown version: ' + version };
      } catch (e) {
        return { valid: false, error: e.message };
      }
    }

    // ==========================================
    // WIF Decoding
    // ==========================================
    function decodeWIF(wif) {
      const data = decodeBase58Check(wif);
      const version = data[0];
      
      if (version !== 0x80 && version !== 0xef) {
        throw new Error('Invalid WIF version');
      }
      
      let privateKey, compressed;
      if (data.length === 34 && data[33] === 0x01) {
        privateKey = data.slice(1, 33);
        compressed = true;
      } else if (data.length === 33) {
        privateKey = data.slice(1, 33);
        compressed = false;
      } else {
        throw new Error('Invalid WIF length');
      }
      
      const privBigInt = bytesToBigInt(privateKey);
      
      // Validate private key is in valid range
      if (privBigInt <= 0n || privBigInt >= SECP256K1.N) {
        throw new Error('Private key out of range');
      }
      
      return {
        privateKey: privBigInt,
        compressed,
        network: version === 0x80 ? 'mainnet' : 'testnet'
      };
    }

    function publicKeyToAddress(publicKeyHex) {
      const pubKeyHash = hash160(publicKeyHex);
      const versionedHash = new Uint8Array(21);
      versionedHash[0] = 0x00; // Mainnet P2PKH
      versionedHash.set(pubKeyHash, 1);
      return base58check(versionedHash);
    }

    function addressToScriptPubKey(address) {
      const validation = validateAddress(address);
      if (!validation.valid) {
        throw new Error('Invalid address: ' + validation.error);
      }
      
      const data = decodeBase58Check(address);
      const pubKeyHash = data.slice(1);
      
      if (data[0] === 0x00 || data[0] === 0x6f) {
        // P2PKH: OP_DUP OP_HASH160 <hash> OP_EQUALVERIFY OP_CHECKSIG
        return '76a914' + bytesToHex(pubKeyHash) + '88ac';
      }
      
      throw new Error('Only P2PKH addresses supported');
    }

    // ==========================================
    // Transaction Building
    // ==========================================
    function varInt(n) {
      if (n < 0xfd) {
        return n.toString(16).padStart(2, '0');
      } else if (n <= 0xffff) {
        return 'fd' + n.toString(16).padStart(4, '0').match(/../g).reverse().join('');
      } else if (n <= 0xffffffff) {
        return 'fe' + n.toString(16).padStart(8, '0').match(/../g).reverse().join('');
      }
      throw new Error('VarInt too large');
    }

    function writeUInt32LE(n) {
      return n.toString(16).padStart(8, '0').match(/../g).reverse().join('');
    }

    function writeUInt64LE(n) {
      const low = n & 0xffffffff;
      const high = Math.floor(n / 0x100000000);
      return writeUInt32LE(low) + writeUInt32LE(high);
    }

    const DUST_THRESHOLD = 546;

    function buildTransaction(utxo, keyData, destAddress, amountSats, feeSats) {
      // Validate inputs
      if (!utxo || !utxo.txid || utxo.sats === undefined) {
        throw new Error('Invalid UTXO');
      }
      if (!keyData || !keyData.privateKey) {
        throw new Error('Invalid key');
      }
      if (amountSats < DUST_THRESHOLD) {
        throw new Error('Amount below dust threshold (' + DUST_THRESHOLD + ' sats)');
      }
      
      const publicKey = SECP256K1.getPublicKey(keyData.privateKey, keyData.compressed);
      const sourceAddress = publicKeyToAddress(publicKey);
      
      // Build transaction components
      const prevTxId = reverseHex(utxo.txid);
      const prevVout = writeUInt32LE(utxo.vout);
      const sequence = 'ffffffff';
      const locktime = '00000000';
      const version = '01000000';
      const hashType = '41000000'; // SIGHASH_ALL | SIGHASH_FORKID
      
      // Destination output
      const destScript = addressToScriptPubKey(destAddress);
      const destScriptLen = varInt(destScript.length / 2);
      
      // Calculate change
      const inputSats = utxo.sats;
      let changeSats = inputSats - amountSats - feeSats;
      
      // Build outputs
      let outputs;
      if (changeSats >= DUST_THRESHOLD) {
        const changeScript = addressToScriptPubKey(sourceAddress);
        const changeScriptLen = varInt(changeScript.length / 2);
        outputs = '02' + 
          writeUInt64LE(amountSats) + destScriptLen + destScript +
          writeUInt64LE(changeSats) + changeScriptLen + changeScript;
      } else {
        // No change output (change goes to fee)
        changeSats = 0;
        outputs = '01' + writeUInt64LE(amountSats) + destScriptLen + destScript;
      }
      
      // Source script for signing (BIP143)
      const sourceScript = addressToScriptPubKey(sourceAddress);
      const sourceScriptLen = varInt(sourceScript.length / 2);
      
      // BIP143 preimage components
      const hashPrevouts = bytesToHex(hash256(prevTxId + prevVout));
      const hashSequence = bytesToHex(hash256(sequence));
      const hashOutputs = bytesToHex(hash256(outputs.slice(2))); // Skip output count
      
      // Construct preimage
      const preimage = version +
        hashPrevouts +
        hashSequence +
        prevTxId + prevVout +
        sourceScriptLen + sourceScript +
        writeUInt64LE(inputSats) +
        sequence +
        hashOutputs +
        locktime +
        hashType;
      
      // Sign
      const sigHash = bytesToHex(hash256(preimage));
      const sig = SECP256K1.sign(sigHash, keyData.privateKey);
      
      // Verify signature before using (defense in depth)
      if (!SECP256K1.verifySignature(sigHash, sig.r, sig.s, publicKey)) {
        throw new Error('Signature verification failed - do not broadcast');
      }
      
      const derSig = SECP256K1.signatureToDER(sig.r, sig.s) + '41'; // Append hash type
      
      // Build scriptSig
      const sigLen = varInt(derSig.length / 2);
      const pubKeyLen = varInt(publicKey.length / 2);
      const scriptSig = sigLen + derSig + pubKeyLen + publicKey;
      const scriptSigLen = varInt(scriptSig.length / 2);
      
      // Build final transaction
      const rawTx = version +
        '01' + // Input count
        prevTxId + prevVout +
        scriptSigLen + scriptSig +
        sequence +
        outputs +
        locktime;
      
      // Calculate txid
      const txid = reverseHex(bytesToHex(hash256(rawTx)));
      
      return {
        rawTx,
        txid,
        size: rawTx.length / 2,
        fee: feeSats + (changeSats < DUST_THRESHOLD && changeSats > 0 ? changeSats : 0),
        change: changeSats >= DUST_THRESHOLD ? changeSats : 0
      };
    }

    // ==========================================
    // UI State
    // ==========================================
    let currentEnvelope = null;
    let currentKey = null;

    // ==========================================
    // UI Functions
    // ==========================================
    window.parseEnvelope = function() {
      const input = document.getElementById('envelope-input').value.trim();
      const infoDiv = document.getElementById('envelope-info');
      
      try {
        const envelope = JSON.parse(input);
        
        if (!envelope.txid) throw new Error('Missing txid');
        if (!envelope.rawTx) throw new Error('Missing rawTx');
        
        // Get satoshis
        let sats;
        if (typeof envelope.satoshis === 'number') {
          sats = envelope.satoshis;
        } else if (typeof envelope.value === 'number') {
          sats = Math.round(envelope.value * 100000000);
        } else {
          throw new Error('Missing value or satoshis');
        }
        
        if (sats <= 0) throw new Error('Invalid value');
        
        currentEnvelope = {
          txid: envelope.txid,
          vout: typeof envelope.vout === 'number' ? envelope.vout : 0,
          sats: sats
        };
        
        document.getElementById('info-txid').textContent = envelope.txid.slice(0, 16) + '...';
        document.getElementById('info-vout').textContent = currentEnvelope.vout;
        document.getElementById('info-value').textContent = (sats / 100000000).toFixed(8) + ' BSV';
        infoDiv.classList.remove('hidden');
        
      } catch (e) {
        alert('Error parsing envelope: ' + e.message);
        currentEnvelope = null;
        infoDiv.classList.add('hidden');
      }
    };

    window.verifyKey = function() {
      const wif = document.getElementById('private-key').value.trim();
      const infoDiv = document.getElementById('key-info');
      
      try {
        const keyData = decodeWIF(wif);
        const publicKey = SECP256K1.getPublicKey(keyData.privateKey, keyData.compressed);
        const address = publicKeyToAddress(publicKey);
        
        currentKey = keyData;
        
        document.getElementById('info-address').textContent = address;
        document.getElementById('info-format').textContent = keyData.compressed ? 'Compressed' : 'Uncompressed';
        infoDiv.classList.remove('hidden');
        
      } catch (e) {
        alert('Error decoding key: ' + e.message);
        currentKey = null;
        infoDiv.classList.add('hidden');
      }
    };

    // Pending transaction data for confirmation
    let pendingTx = null;

    window.signTransaction = function() {
      const resultDiv = document.getElementById('tx-result');
      const errorDiv = document.getElementById('tx-error');
      
      resultDiv.classList.add('hidden');
      errorDiv.classList.add('hidden');
      
      try {
        // Validate state
        if (!currentEnvelope) {
          throw new Error('Please load an SPV envelope first (Step 1)');
        }
        if (!currentKey) {
          throw new Error('Please enter and verify your private key (Step 2)');
        }
        
        // Validate destination
        const destAddress = document.getElementById('dest-address').value.trim();
        if (!destAddress) {
          throw new Error('Please enter a destination address (Step 3)');
        }
        
        const destValidation = validateAddress(destAddress);
        if (!destValidation.valid) {
          throw new Error('Invalid destination address: ' + destValidation.error);
        }
        
        // Calculate amounts
        const sendAmountInput = document.getElementById('send-amount').value.trim();
        const feeRate = parseInt(document.getElementById('fee-rate').value) || 1;
        
        if (feeRate < 1 || feeRate > 1000) {
          throw new Error('Fee rate must be between 1 and 1000 sat/byte');
        }
        
        // Estimate size: ~148 bytes per input + ~34 bytes per output + 10 bytes overhead
        // For 1-in-2-out: ~148 + 68 + 10 = ~226 bytes
        const estimatedSize = 226;
        const feeSats = estimatedSize * feeRate;
        
        let amountSats;
        if (sendAmountInput) {
          amountSats = Math.round(parseFloat(sendAmountInput) * 100000000);
          if (isNaN(amountSats) || amountSats <= 0) {
            throw new Error('Invalid send amount');
          }
        } else {
          // Send all (minus fee)
          amountSats = currentEnvelope.sats - feeSats;
        }
        
        // Check sufficient funds
        if (amountSats + feeSats > currentEnvelope.sats) {
          throw new Error('Insufficient funds. Have ' + currentEnvelope.sats + ' sats, need ' + (amountSats + feeSats) + ' sats');
        }
        
        // Calculate change
        const changeSats = currentEnvelope.sats - amountSats - feeSats;
        
        // Get source address
        const publicKey = SECP256K1.getPublicKey(currentKey.privateKey, currentKey.compressed);
        const sourceAddress = publicKeyToAddress(publicKey);
        
        // Store pending transaction details
        pendingTx = {
          envelope: currentEnvelope,
          key: currentKey,
          destAddress: destAddress,
          amountSats: amountSats,
          feeSats: feeSats,
          changeSats: changeSats,
          sourceAddress: sourceAddress
        };
        
        // Show confirmation modal
        document.getElementById('confirm-from').textContent = sourceAddress;
        document.getElementById('confirm-to').textContent = destAddress;
        document.getElementById('confirm-amount').textContent = (amountSats / 100000000).toFixed(8) + ' BSV';
        document.getElementById('confirm-fee').textContent = feeSats + ' sats';
        document.getElementById('confirm-change').textContent = changeSats > 546 ? (changeSats / 100000000).toFixed(8) + ' BSV' : 'None (dust)';
        document.getElementById('confirm-modal').classList.remove('hidden');
        
      } catch (e) {
        errorDiv.textContent = e.message;
        errorDiv.classList.remove('hidden');
      }
    };

    window.cancelSign = function() {
      document.getElementById('confirm-modal').classList.add('hidden');
      pendingTx = null;
    };

    window.confirmSign = function() {
      document.getElementById('confirm-modal').classList.add('hidden');
      
      const resultDiv = document.getElementById('tx-result');
      const errorDiv = document.getElementById('tx-error');
      
      try {
        if (!pendingTx) {
          throw new Error('No pending transaction');
        }
        
        // Build and sign transaction
        const result = buildTransaction(pendingTx.envelope, pendingTx.key, pendingTx.destAddress, pendingTx.amountSats, pendingTx.feeSats);
        
        // Display results
        document.getElementById('result-txid').textContent = result.txid;
        document.getElementById('result-size').textContent = result.size + ' bytes';
        document.getElementById('result-fee').textContent = result.fee + ' sats (' + (result.fee / result.size).toFixed(2) + ' sat/byte)';
        document.getElementById('result-hex').value = result.rawTx;
        
        resultDiv.classList.remove('hidden');
        resultDiv.scrollIntoView({ behavior: 'smooth' });
        
        // Security: Clear sensitive data
        currentKey = null;
        pendingTx = null;
        document.getElementById('private-key').value = '';
        document.getElementById('key-info').classList.add('hidden');
        
      } catch (e) {
        errorDiv.textContent = e.message;
        errorDiv.classList.remove('hidden');
      }
    };

    window.copyTx = function() {
      const hex = document.getElementById('result-hex').value;
      navigator.clipboard.writeText(hex).then(() => {
        alert('Copied to clipboard');
      }).catch(() => {
        // Fallback for older browsers
        document.getElementById('result-hex').select();
        document.execCommand('copy');
        alert('Copied to clipboard');
      });
    };

    window.downloadTx = function() {
      const hex = document.getElementById('result-hex').value;
      const txid = document.getElementById('result-txid').textContent.slice(0, 8);
      const blob = new Blob([hex], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'signed-tx-' + txid + '.txt';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };

    window.showQRCode = function() {
      const hex = document.getElementById('result-hex').value;
      if (!hex) {
        alert('No signed transaction to display');
        return;
      }
      
      try {
        // Generate QR code (use uppercase hex for alphanumeric mode efficiency)
        const matrix = QRCode.generate(hex.toUpperCase(), 0); // 0 = Low EC for max capacity
        
        // Render to canvas
        const canvas = document.getElementById('qr-canvas');
        const scale = Math.min(8, Math.floor(320 / matrix.length));
        QRCode.toCanvas(matrix, canvas, scale, 2);
        
        // Show info
        const txid = document.getElementById('result-txid').textContent;
        document.getElementById('qr-info').textContent = 
          'TX: ' + txid.slice(0, 8) + '... | ' + hex.length + ' chars | QR v' + Math.ceil((matrix.length - 17) / 4);
        
        // Show modal
        document.getElementById('qr-modal').classList.remove('hidden');
        
        console.log('QR code generated:', matrix.length + 'x' + matrix.length, 'modules');
        
      } catch (e) {
        console.error('QR generation failed:', e);
        alert('Failed to generate QR code: ' + e.message + '\n\nTransaction may be too large for QR code.');
      }
    };

    window.closeQRCode = function() {
      document.getElementById('qr-modal').classList.add('hidden');
    };

    window.saveQRCode = function() {
      const canvas = document.getElementById('qr-canvas');
      const txid = document.getElementById('result-txid').textContent.slice(0, 8);
      
      // Convert canvas to PNG
      const link = document.createElement('a');
      link.download = 'signed-tx-' + txid + '-qr.png';
      link.href = canvas.toDataURL('image/png');
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    };

    // Self-test: Verify crypto implementation on load
    (function selfTest() {
      try {
        // Test vector from Bitcoin
        const testPrivKey = BigInt('0x0000000000000000000000000000000000000000000000000000000000000001');
        const expectedPubKey = '0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798';
        const pubKey = SECP256K1.getPublicKey(testPrivKey, true);
        if (pubKey !== expectedPubKey) {
          throw new Error('Public key derivation failed: got ' + pubKey);
        }
        console.log('Self-test: Public key OK');
        
        // Test SHA256
        const testHash = bytesToHex(SHA256.hash(new Uint8Array([0x61, 0x62, 0x63]))); // "abc"
        if (testHash !== 'ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad') {
          throw new Error('SHA256 failed: got ' + testHash);
        }
        console.log('Self-test: SHA256 OK');
        
        // Test signature only (skip verification for now as it may have env-specific issues)
        const msgHash = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';
        const sig = SECP256K1.sign(msgHash, testPrivKey);
        if (!sig || !sig.r || !sig.s) {
          throw new Error('Signing failed: no signature returned');
        }
        console.log('Self-test: Signing OK');
        console.log('Self-test: r=' + sig.r.toString(16).slice(0,16) + '...');
        console.log('Self-test: s=' + sig.s.toString(16).slice(0,16) + '...');
        
        // Verify signature
        const verifyResult = SECP256K1.verifySignature(msgHash, sig.r, sig.s, pubKey);
        console.log('Self-test: Verify result=' + verifyResult);
        if (!verifyResult) {
          throw new Error('Signature verification failed');
        }
        
        console.log('Self-test passed: All crypto functions working correctly');
      } catch (e) {
        console.error('CRITICAL: Self-test failed:', e.message);
        console.error(e.stack);
        alert('WARNING: Cryptographic self-test failed. Do not use this page. Error: ' + e.message);
      }
    })();

    // ==========================================
    // Network Detection
    // ==========================================
    let networkWarningDismissed = false;

    async function checkNetworkStatus() {
      const statusBar = document.getElementById('network-status');
      const statusText = document.getElementById('network-status-text');
      const modal = document.getElementById('network-modal');
      
      // Method 1: navigator.onLine (quick but not always reliable)
      const browserSaysOnline = navigator.onLine;
      
      // Method 2: Actually try to fetch something (more reliable)
      let canReachNetwork = false;
      
      if (browserSaysOnline) {
        try {
          // Try to fetch a tiny resource with a short timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 3000);
          
          // Use a reliable, fast endpoint - just checking if we get any response
          const response = await fetch('https://www.google.com/favicon.ico', {
            method: 'HEAD',
            mode: 'no-cors',
            cache: 'no-store',
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          canReachNetwork = true;
        } catch (e) {
          // Fetch failed - likely offline
          canReachNetwork = false;
        }
      }
      
      const isOnline = browserSaysOnline && canReachNetwork;
      
      if (isOnline) {
        statusBar.className = 'status-bar online';
        statusText.textContent = 'Network detected — disconnect for maximum security';
        console.log('Network status: ONLINE (connected to internet)');
        
        // Show warning modal if not dismissed
        if (!networkWarningDismissed) {
          modal.classList.remove('hidden');
        }
      } else {
        statusBar.className = 'status-bar offline';
        statusText.textContent = 'Offline — secure signing environment';
        console.log('Network status: OFFLINE (no internet connection)');
        modal.classList.add('hidden');
      }
      
      return isOnline;
    }

    window.dismissNetworkWarning = function() {
      networkWarningDismissed = true;
      document.getElementById('network-modal').classList.add('hidden');
      console.log('Network warning dismissed by user');
    };

    window.checkNetworkAgain = async function() {
      document.getElementById('network-modal').classList.add('hidden');
      
      // Brief delay to let network state update
      await new Promise(resolve => setTimeout(resolve, 500));
      
      const stillOnline = await checkNetworkStatus();
      if (!stillOnline) {
        console.log('Network disconnected successfully');
      }
    };

    // Check network status on page load
    checkNetworkStatus();

    // Also monitor for network changes
    window.addEventListener('online', () => {
      console.log('Network event: came online');
      checkNetworkStatus();
    });
    
    window.addEventListener('offline', () => {
      console.log('Network event: went offline');
      checkNetworkStatus();
    });

    // ==========================================
    // Page Integrity Hash Verification
    // ==========================================
    
    async function computePageIntegrity() {
      const valueEl = document.getElementById('integrity-value');
      const statusEl = document.getElementById('integrity-status');
      
      try {
        statusEl.textContent = '(computing...)';
        statusEl.className = 'integrity-status computing';
        
        // Get the full page source as rendered
        // Note: This may differ slightly from the original file due to browser parsing
        // For exact verification, users should hash the downloaded file directly
        let pageSource = document.documentElement.outerHTML;
        
        // Normalize only the dynamic elements that change between loads:
        // 1. The hash display itself (circular dependency)
        pageSource = pageSource.replace(
          /<code id="integrity-value">[^<]*<\/code>/g,
          '<code id="integrity-value">HASH_PLACEHOLDER</code>'
        );
        
        // 2. The integrity status text
        pageSource = pageSource.replace(
          /<span id="integrity-status"[^>]*>[^<]*<\/span>/g,
          '<span id="integrity-status"></span>'
        );
        
        // 3. Network status (varies based on connection)
        pageSource = pageSource.replace(
          /<span id="network-status-text">[^<]*<\/span>/g,
          '<span id="network-status-text">STATUS</span>'
        );
        
        // 4. Network status bar class
        pageSource = pageSource.replace(
          /id="network-status" class="status-bar[^"]*"/g,
          'id="network-status" class="status-bar normalized"'
        );
        
        // Convert to bytes using UTF-8
        const encoder = new TextEncoder();
        const data = encoder.encode(pageSource);
        
        // Compute SHA-256 using our existing implementation
        const hashBytes = SHA256.hash(data);
        const hashHex = bytesToHex(hashBytes);
        
        // Display truncated hash
        const displayHash = hashHex.slice(0, 16) + '...' + hashHex.slice(-8);
        valueEl.textContent = displayHash;
        valueEl.title = 'Full SHA-256: ' + hashHex + '\nClick to copy';
        valueEl.style.cursor = 'pointer';
        valueEl.onclick = function() {
          navigator.clipboard.writeText(hashHex).then(() => {
            statusEl.textContent = '(copied!)';
            setTimeout(() => {
              statusEl.textContent = '(verify on GitHub)';
            }, 1500);
          });
        };
        
        statusEl.textContent = '(verify on GitHub)';
        statusEl.className = 'integrity-status';
        
        console.log('Page integrity hash computed:', hashHex);
        return hashHex;
        
      } catch (e) {
        console.error('Failed to compute integrity hash:', e);
        valueEl.textContent = 'Error';
        statusEl.textContent = '';
        return null;
      }
    }
    
    // Compute integrity hash after page fully loads
    if (document.readyState === 'complete') {
      computePageIntegrity();
    } else {
      window.addEventListener('load', computePageIntegrity);
    }

  })();
  </script>
</body>
</html>
